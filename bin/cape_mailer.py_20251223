#!/usr/bin/env python3
import os
import re
import ssl
import json
import time
import yaml
import shlex
import smtplib
import hashlib
import subprocess
from email.message import EmailMessage
from email.utils import formatdate

import requests
import pyzipper
from imapclient import IMAPClient
import pyzmail


BASE = "/opt/cape-mailer"
WORK = os.path.join(BASE, "work")
PROCESSED = os.path.join(BASE, "processed")
QUAR = os.path.join(BASE, "quarantine")
LOGDIR = os.path.join(BASE, "logs")


def load_cfg(path="/opt/cape-mailer/config.yaml"):
    with open(path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)


def sha256_file(p: str) -> str:
    h = hashlib.sha256()
    with open(p, "rb") as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b""):
            h.update(chunk)
    return h.hexdigest()


def send_mail(cfg, to_addr, subject, html_body, text_body=None):
    msg = EmailMessage()
    msg["From"] = cfg["smtp"]["from"]
    msg["To"] = to_addr
    msg["Date"] = formatdate(localtime=True)
    msg["Subject"] = subject

    if not text_body:
        text_body = re.sub(r"<[^>]+>", "", html_body)

    msg.set_content(text_body)
    msg.add_alternative(html_body, subtype="html")

    host = cfg["smtp"]["host"]
    port = int(cfg["smtp"]["port"])
    starttls = bool(cfg["smtp"].get("starttls", True))

    with smtplib.SMTP(host, port, timeout=30) as s:
        s.ehlo()
        if starttls:
            s.starttls(context=ssl.create_default_context())
            s.ehlo()
        if cfg["smtp"].get("user"):
            s.login(cfg["smtp"]["user"], cfg["smtp"]["pass"])
        s.send_message(msg)


def extract_password(cfg, body_text: str) -> str | None:
    rx = re.compile(cfg["parsing"]["password_regex"])
    m = rx.search(body_text or "")
    if not m:
        return None
    return m.group(1).strip()


def save_attachment(msg: pyzmail.PyzMessage, part_idx: int, outdir: str) -> str | None:
    part = msg.mailparts[part_idx]
    filename = part.filename
    if not filename:
        return None

    # sanitize filename
    filename = filename.replace("\\", "_").replace("/", "_").strip()
    path = os.path.join(outdir, filename)

    payload = part.get_payload()
    with open(path, "wb") as f:
        f.write(payload)
    return path


def is_allowed(cfg, path: str) -> bool:
    ext = os.path.splitext(path)[1].lower().lstrip(".")
    return ext in set(cfg["parsing"]["allowed_extensions"])


def unpack_zip_with_password(zip_path: str, password: str | None, outdir: str) -> list[str]:
    extracted = []
    pw = password.encode("utf-8") if password else None
    with pyzipper.AESZipFile(zip_path) as zf:
        for name in zf.namelist():
            # skip directories
            if name.endswith("/"):
                continue
            tgt = os.path.join(outdir, os.path.basename(name))
            with zf.open(name, pwd=pw) as src, open(tgt, "wb") as dst:
                dst.write(src.read())
            extracted.append(tgt)
    return extracted


def unpack_with_7z(archive_path: str, password: str | None, outdir: str) -> list[str]:
    # 7z x -y -oOUT [-pPASS] ARCHIVE
    cmd = ["7z", "x", "-y", f"-o{outdir}"]
    if password:
        cmd.append(f"-p{password}")
    cmd.append(archive_path)

    p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    if p.returncode != 0:
        raise RuntimeError(f"7z failed: {p.stdout}")

    # collect extracted files
    extracted = []
    for root, _, files in os.walk(outdir):
        for fn in files:
            extracted.append(os.path.join(root, fn))
    return extracted


def collect_samples(cfg, attach_paths: list[str], password: str | None, workdir: str) -> list[str]:
    """
    Returns list of files to submit (best effort).
    - If attachment is archive: try extract using pw from body
    - If attachment is not archive: submit directly
    """
    submit = []

    for p in attach_paths:
        ext = os.path.splitext(p)[1].lower()
        if ext == ".zip":
            try:
                extracted = unpack_zip_with_password(p, password, workdir)
                submit.extend(extracted)
            except Exception:
                # fallback to 7z if zip encryption variant not supported by pyzipper
                extracted = unpack_with_7z(p, password, workdir)
                submit.extend(extracted)
        elif ext in (".7z", ".rar"):
            extracted = unpack_with_7z(p, password, workdir)
            submit.extend(extracted)
        else:
            submit.append(p)

    # filter by allowlist extensions
    submit2 = [s for s in submit if os.path.isfile(s) and is_allowed(cfg, s)]
    # If archive had nested directories, keep basename duplicates safe:
    return submit2


def cape_submit(cfg, sample_path: str) -> int:
    """
    Submits sample via configured command, expects JSON output with task_id or id.
    """
    cmd_tmpl = cfg["capesubmit"]["submit_cmd"]
    machine = (cfg["capesubmit"].get("machine") or "").strip()
    machine_opt = f"--machine {shlex.quote(machine)}" if machine else ""
    cmd = cmd_tmpl.format(
        timeout=int(cfg["capesubmit"]["timeout"]),
        route=cfg["capesubmit"]["route"],
        machine_opt=machine_opt,
        sample=shlex.quote(sample_path),
    )

    p = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    if p.returncode != 0:
        raise RuntimeError(f"CAPE submit failed: {p.stdout}")

    # Try parse JSON from output
    out = p.stdout.strip()
    # find first '{' .. '}'
    jstart = out.find("{")
    jend = out.rfind("}")
    if jstart >= 0 and jend > jstart:
        data = json.loads(out[jstart:jend+1])
        for k in ("task_id", "id", "taskid"):
            if k in data:
                return int(data[k])

    # fallback: regex "Task #17" or similar
    m = re.search(r"\bTask\s*#\s*(\d+)\b", out)
    if m:
        return int(m.group(1))

    raise RuntimeError(f"Could not determine task id from submit output: {out[:500]}")


def wait_for_report(cfg, task_id: int) -> dict:
    """
    Wait for report.json (best effort). CAPE produces multiple report formats; we try common paths.
    """
    analyses_dir = cfg["caperesults"]["analyses_dir"]
    max_wait = int(cfg["caperesults"]["max_wait"])
    poll = int(cfg["caperesults"]["poll_interval"])

    base = os.path.join(analyses_dir, str(task_id))
    candidates = [
        os.path.join(base, "reports", "report.json"),
        os.path.join(base, "reports", "report.json.gz"),
        os.path.join(base, "reports", "cape_report.json"),
    ]

    deadline = time.time() + max_wait
    while time.time() < deadline:
        for c in candidates:
            if os.path.exists(c) and c.endswith(".json"):
                with open(c, "r", encoding="utf-8", errors="replace") as f:
                    return json.load(f)
        time.sleep(poll)

    raise TimeoutError(f"No report found for task {task_id} within {max_wait}s")


def compute_ampel(cfg, report: dict) -> tuple[str, str]:
    """
    Returns (color_emoji, reasoning_short)
    CAPE typically has "malscore" in report. If missing, fallback conservative.
    """
    malscore = None
    if isinstance(report, dict):
        malscore = report.get("malscore")
        if malscore is None and "info" in report and isinstance(report["info"], dict):
            malscore = report["info"].get("score")  # fallback

    # Conservative defaults
    if malscore is None:
        return "üü†", "Kein Malscore verf√ºgbar ‚Äì konservativ als verd√§chtig eingestuft."

    try:
        ms = float(malscore)
    except Exception:
        return "üü†", f"Malscore nicht interpretierbar ({malscore}) ‚Äì konservativ gelb."

    gmax = float(cfg["ampel"]["green_max_malscore"])
    ymax = float(cfg["ampel"]["yellow_max_malscore"])

    if ms <= gmax:
        return "üü¢", f"Malscore {ms:.1f} ‚â§ {gmax:.1f}"
    if ms <= ymax:
        return "üü†", f"Malscore {ms:.1f} zwischen {gmax:.1f} und {ymax:.1f}"
    return "üî¥", f"Malscore {ms:.1f} > {ymax:.1f}"


def ollama_eval(cfg, report: dict, sample_meta: dict) -> str:
    if not cfg["ollama"].get("enabled", False):
        return "Ollama ist deaktiviert."

    host = cfg["ollama"]["host"].rstrip("/")
    model = cfg["ollama"]["model"]
    timeout = int(cfg["ollama"].get("timeout", 120))

    # Keep prompt compact but bank-oriented
    prompt = f"""
Du bist ein Senior SOC Analyst (Bank, Deutschland) und bewertest Malware-Sandbox-Ergebnisse.
Gib eine kurze Bewertung mit:
- Risiko (Low/Medium/High/Critical)
- Relevanz f√ºr eine regulierte Bank (z.B. Zahlungsverkehr, Auth, Ransomware, Datenabfluss)
- Empfohlene Ma√ünahmen (technisch + organisatorisch)
- Begr√ºndung anhand der CAPE-Befunde.

Sample-Metadaten:
{json.dumps(sample_meta, ensure_ascii=False, indent=2)}

CAPE-Report (gek√ºrzt/roh):
{json.dumps(report, ensure_ascii=False)[:12000]}
""".strip()

    payload = {"model": model, "prompt": prompt, "stream": False}
    r = requests.post(f"{host}/api/generate", json=payload, timeout=timeout)
    r.raise_for_status()
    data = r.json()
    return data.get("response", "").strip() or "Keine LLM-Antwort erhalten."


def main():
    cfg = load_cfg()
    os.makedirs(WORK, exist_ok=True)
    os.makedirs(PROCESSED, exist_ok=True)
    os.makedirs(QUAR, exist_ok=True)
    os.makedirs(LOGDIR, exist_ok=True)

    imap_cfg = cfg["imap"]
    smtp_cfg = cfg["smtp"]

    # IMAP connect
    with IMAPClient(imap_cfg["host"], port=int(imap_cfg["port"]), ssl=bool(imap_cfg["ssl"])) as server:
        server.login(imap_cfg["user"], imap_cfg["pass"])
        server.select_folder(imap_cfg.get("folder", "INBOX"))

        # unseen
        messages = server.search(["UNSEEN"])
        for uid in messages:
            raw = server.fetch(uid, ["RFC822"])[uid][b"RFC822"]
            msg = pyzmail.PyzMessage.factory(raw)

            from_addr = msg.get_addresses("from")[0][1] if msg.get_addresses("from") else ""
            subj = msg.get_subject() or "(no subject)"

            # Body text for password extraction
            body_text = ""
            if msg.text_part:
                body_text = msg.text_part.get_payload().decode(msg.text_part.charset or "utf-8", errors="replace")
            elif msg.html_part:
                body_text = msg.html_part.get_payload().decode(msg.html_part.charset or "utf-8", errors="replace")

            password = extract_password(cfg, body_text)

            # Prepare per-mail working dir
            mail_dir = os.path.join(WORK, f"uid_{uid}")
            os.makedirs(mail_dir, exist_ok=True)

            attach_paths = []
            for i, part in enumerate(msg.mailparts):
                if part.is_body:
                    continue
                p = save_attachment(msg, i, mail_dir)
                if not p:
                    continue

                size_mb = os.path.getsize(p) / (1024 * 1024)
                if size_mb > float(cfg["parsing"]["max_attach_mb"]):
                    # too big -> quarantine
                    os.rename(p, os.path.join(QUAR, os.path.basename(p)))
                    continue

                attach_paths.append(p)

            # No attachments: mark seen, skip
            if not attach_paths:
                server.add_flags(uid, ["\\Seen"])
                continue

            # Collect submission candidates (unpack if needed)
            try:
                candidates = collect_samples(cfg, attach_paths, password, mail_dir)
            except Exception as e:
                html = f"""
                <h2 style="color:orange">üü† Analyse nicht m√∂glich</h2>
                <p>Betreff: {subj}</p>
                <p>Fehler beim Entpacken/Verarbeiten der Anh√§nge: <pre>{str(e)}</pre></p>
                """
                send_mail(cfg, from_addr, f"{smtp_cfg['reply_subject_prefix']} {subj}", html)
                server.add_flags(uid, ["\\Seen"])
                continue

            if not candidates:
                html = f"""
                <h2 style="color:orange">üü† Keine analysierbaren Dateien gefunden</h2>
                <p>Betreff: {subj}</p>
                <p>Hinweis: Zul√§ssige Endungen: {", ".join(cfg["parsing"]["allowed_extensions"])}</p>
                """
                send_mail(cfg, from_addr, f"{smtp_cfg['reply_subject_prefix']} {subj}", html)
                server.add_flags(uid, ["\\Seen"])
                continue

            # Submit first candidate (oder alle ‚Äì hier bewusst: alle nacheinander, aber Ergebnis pro Datei)
            results_blocks = []
            for sample in candidates:
                meta = {
                    "original_subject": subj,
                    "sender": from_addr,
                    "filename": os.path.basename(sample),
                    "sha256": sha256_file(sample),
                    "password_in_mail": bool(password),
                }

                try:
                    task_id = cape_submit(cfg, sample)
                    report = wait_for_report(cfg, task_id)
                    ampel, reason = compute_ampel(cfg, report)
                    llm = ollama_eval(cfg, report, meta)

                    # CAPE summary (best effort)
                    malscore = report.get("malscore", report.get("info", {}).get("score", "n/a"))
                    procs = report.get("behavior", {}).get("processes", [])
                    proc_count = len(procs) if isinstance(procs, list) else "n/a"

                    results_blocks.append(f"""
                    <hr>
                    <h3>{ampel} Ergebnis f√ºr: {meta["filename"]}</h3>
                    <p><b>SHA256:</b> <code>{meta["sha256"]}</code><br>
                       <b>Task-ID:</b> {task_id}<br>
                       <b>Malscore:</b> {malscore}<br>
                       <b>Begr√ºndung:</b> {reason}<br>
                       <b>Prozesse:</b> {proc_count}</p>
                    <details>
                      <summary><b>LLM-Risikobewertung (Ollama)</b></summary>
                      <pre>{llm}</pre>
                    </details>
                    """)
                except Exception as e:
                    results_blocks.append(f"""
                    <hr>
                    <h3>üü† Fehler bei: {meta["filename"]}</h3>
                    <p><b>SHA256:</b> <code>{meta["sha256"]}</code></p>
                    <pre>{str(e)}</pre>
                    """)

            # Compose overall mail with ‚ÄúAmpel-Header‚Äù
            # Determine worst color
            worst = "üü¢"
            if any("üî¥" in b for b in results_blocks):
                worst = "üî¥"
            elif any("üü†" in b for b in results_blocks):
                worst = "üü†"

            color = {"üü¢": "green", "üü†": "orange", "üî¥": "red"}[worst]
            header = f"<h2 style='color:{color}'>{worst} CAPE Analyse ‚Äì Handlungsempfehlung</h2>"

            rec = {
                "üü¢": "<p><b>Empfehlung:</b> Datei kann i.d.R. freigegeben werden. Bei Kontextverdacht dennoch manuelle Pr√ºfung.</p>",
                "üü†": "<p><b>Empfehlung:</b> Nicht √∂ffnen. SOC/ITSO entscheidet nach manueller Validierung (IOC-Abgleich, Reputation, Kontext).</p>",
                "üî¥": "<p><b>Empfehlung:</b> Nicht √∂ffnen. Quarant√§ne/Block, Incident pr√ºfen (DORA/BAIT-relevant), IOCs verteilen.</p>",
            }[worst]

            html = f"""
            {header}
            <p><b>Original-Betreff:</b> {subj}<br>
               <b>Absender:</b> {from_addr}<br>
               <b>Passwort erkannt:</b> {"ja" if password else "nein"}</p>
            {rec}
            {''.join(results_blocks)}
            """

            send_mail(cfg, from_addr, f"{smtp_cfg['reply_subject_prefix']} {subj}", html)

            # mark as seen and optionally move
            server.add_flags(uid, ["\\Seen"])
            move_to = imap_cfg.get("move_to_folder")
            if move_to:
                try:
                    server.move([uid], move_to)
                except Exception:
                    pass


if __name__ == "__main__":
    main()

