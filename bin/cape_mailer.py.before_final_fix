#!/usr/bin/env python3
"""
CAPE Mailer - Malware Analysis & Phishing Detection
=====================================================
Automatische Analyse von E-Mail-Anh√§ngen via CAPE Sandbox.

Features:
- Automatische Archiv-Entpackung (ZIP, 7z, RAR) mit Passwort-Erkennung
- CAPE Sandbox Integration
- Ollama LLM Bewertung
- Phishing-Analyse f√ºr EML/MSG-Dateien mit Multi-Source Auth-Header-Parsing
- Mail-Routing Security-Analyse (TLS, Cipher, ARC, SPF/DKIM/DMARC)
- Banking-spezifische Checks (CEO-Fraud, Typosquatting)
- URL-Pr√ºfung via Tor
- Magic Bytes Detection
- HTML Reports mit Security-Recommendations
- Splunk JSON Logs
- MISP-ready IOC Export

Author: SOC Team
Version: 2.3.0
Changelog v2.3.0:
- Multi-Source OSINT-Integration (OTX, AbuseIPDB, VirusTotal, URLScan, Google Safe Browsing, Spamhaus, IPQualityScore)
- OSINT-Ergebnisse in Ollama-Prompt f√ºr Context-Aware AI-Bewertung
- HTML-Report mit OSINT-Threat-Intelligence-Sektion
- Threat-Score-Aggregation √ºber alle OSINT-Quellen
Changelog v2.2.9:
- Multi-Source SPF/DKIM/DMARC Parsing (Authentication-Results, Received-SPF, X-MS-Exchange-*)
- Detaillierte Mail-Routing-Analyse mit TLS/Cipher-Erkennung
- Security-Recommendations f√ºr Mail-Gateway-Tuning
- ARC-Header-Support
- Erweiterte Security-System-Erkennung (Amazon SES, etc.)
"""

import os
import re
import ssl
import sys
import json
import time
import yaml
import email
import shlex
import socket
import smtplib
import hashlib
import logging
import tempfile
import ipaddress
import subprocess
import urllib3
from email import policy
from email.parser import BytesParser
from email.message import EmailMessage
from email.utils import formatdate
from dataclasses import dataclass, field, asdict
from typing import Optional, List, Dict, Any, Tuple
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
from urllib.parse import urlparse
from pathlib import Path

import requests
import pyzipper
from imapclient import IMAPClient
import pyzmail

# SSL Warnings unterdr√ºcken
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Optional imports f√ºr Phishing-Analyse
try:
    from bs4 import BeautifulSoup
    import dns.resolver
    PHISHING_DEPS_AVAILABLE = True
except ImportError:
    PHISHING_DEPS_AVAILABLE = False
    BeautifulSoup = None

# Optional: extract_msg f√ºr MSG-Dateien
try:
    import extract_msg
    EXTRACT_MSG_AVAILABLE = True
except ImportError:
    EXTRACT_MSG_AVAILABLE = False

# =============================================================================
# CONFIGURATION
# =============================================================================

BASE = "/opt/cape-mailer"
WORK = os.path.join(BASE, "work")
PROCESSED = os.path.join(BASE, "processed")
QUAR = os.path.join(BASE, "quarantine")
LOGDIR = os.path.join(BASE, "logs")
REPORTS_DIR = os.path.join(BASE, "reports")
SPLUNK_LOG_DIR = os.path.join(LOGDIR, "splunk")
CONFIG_DIR = os.path.join(BASE, "config")

# Immer CC an diese Adresse
ALWAYS_CC = "info@mpauli.de"

# Tor SOCKS Proxy f√ºr URL-Checks
TOR_PROXY = "socks5h://127.0.0.1:9050"

# EML/MSG Extensions
EML_EXTENSIONS = ('.eml', '.msg')

# Magic Bytes
MAGIC_BYTES = {
    'exe': b'MZ',
    'dll': b'MZ',
    'zip': b'PK',
    'rar': b'Rar!',
    '7z': b"7z\xbc\xaf'\x1c",
    'pdf': b'%PDF',
    'ole': b'\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1',  # MSG, DOC, XLS
    'ooxml': b'PK',  # DOCX, XLSX, PPTX (ZIP-based)
}

# Banking-spezifische Patterns
GERMAN_BANKS = [
    "sparkasse", "volksbank", "raiffeisenbank", "commerzbank", "deutsche bank",
    "postbank", "ing-diba", "ing", "dkb", "comdirect", "hypovereinsbank", "unicredit",
    "targobank", "santander", "n26", "bunq", "consorsbank", "norisbank", "sparda",
    "apobank", "psd bank", "bw bank", "lbbw", "helaba", "landesbank", "kfw"
]

# CEO/Executive Fraud Keywords
CEO_FRAUD_KEYWORDS = [
    "dringend", "vertraulich", "geheim", "√ºberweisung", "wire transfer",
    "gesch√§ftsf√ºhrer", "ceo", "vorstand", "chef", "direktor",
    "sofort", "immediately", "urgent", "asap", "zeitkritisch",
    "nicht weiterleiten", "nur f√ºr sie", "pers√∂nlich"
]

# Default Archive Passwords
DEFAULT_PASSWORDS = ["infected", "malware", "virus", "password", "123456", "test"]

# =============================================================================
# LOGGING
# =============================================================================

os.makedirs(LOGDIR, exist_ok=True)
os.makedirs(SPLUNK_LOG_DIR, exist_ok=True)
os.makedirs(REPORTS_DIR, exist_ok=True)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s %(levelname)s %(message)s',
    handlers=[
        logging.FileHandler(os.path.join(LOGDIR, f"cape_mailer_{datetime.now().strftime('%Y-%m-%d')}.log")),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# =============================================================================
# DATACLASSES
# =============================================================================

@dataclass
class MailHop:
    """Einzelner Hop in der Mail-Routing-Kette"""
    index: int = 0
    raw_header: str = ""
    from_server: str = ""
    to_server: str = ""
    ips: List[str] = field(default_factory=list)
    tls_version: str = ""
    cipher: str = ""
    protocol: str = ""

@dataclass
class MailRoutingAnalysis:
    """Detaillierte Mail-Routing-Analyse"""
    hops: List[MailHop] = field(default_factory=list)
    total_hops: int = 0
    uses_tls: bool = False
    weak_tls: bool = False
    weak_cipher: bool = False
    has_arc: bool = False
    security_issues: List[str] = field(default_factory=list)
    recommendations: List[Dict] = field(default_factory=list)

@dataclass
class HeaderAnalysis:
    from_address: str = ""
    from_display: str = ""
    reply_to: str = ""
    return_path: str = ""
    subject: str = ""
    date: str = ""
    message_id: str = ""
    spf_result: str = ""
    spf_source: str = ""  # NEU: Woher kam das SPF-Ergebnis?
    dkim_result: str = ""
    dkim_source: str = ""  # NEU
    dmarc_result: str = ""
    dmarc_source: str = ""  # NEU
    originating_ip: str = ""
    originating_country: str = ""
    received_chain: List[Dict] = field(default_factory=list)
    security_systems: List[str] = field(default_factory=list)
    anomalies: List[str] = field(default_factory=list)
    risk_score: int = 0
    routing_analysis: MailRoutingAnalysis = field(default_factory=MailRoutingAnalysis)  # NEU

@dataclass
class URLAnalysis:
    url: str = ""
    domain: str = ""
    is_reachable: bool = False
    final_url: str = ""
    has_login_form: bool = False
    is_typosquatting: bool = False
    typosquatting_target: str = ""
    ssl_valid: bool = False
    url_risk_score: int = 0
    risk_reasons: List[str] = field(default_factory=list)

@dataclass
class ContentAnalysis:
    extracted_urls: List[str] = field(default_factory=list)
    extracted_ibans: List[str] = field(default_factory=list)
    ceo_fraud_indicators: List[str] = field(default_factory=list)
    urgency_score: int = 0
    bank_mentions: List[str] = field(default_factory=list)
    suspicious_phrases: List[str] = field(default_factory=list)
    has_tracking_pixels: bool = False
    content_risk_score: int = 0

@dataclass
class AttachmentAnalysis:
    filename: str = ""
    filetype: str = ""
    sha256: str = ""
    size: int = 0
    is_executable: bool = False
    has_macros: bool = False
    is_double_extension: bool = False
    risk_score: int = 0
    risk_reasons: List[str] = field(default_factory=list)


@dataclass
class OSINTIPReputation:
    """OSINT IP Reputation"""
    ip: str = ""
    otx_pulses: List[Dict] = field(default_factory=list)
    otx_malicious: bool = False
    abuseipdb_score: int = 0
    virustotal_malicious: int = 0
    virustotal_total: int = 0
    spamhaus_listed: bool = False
    ipqs_fraud_score: int = 0
    overall_threat_score: int = 0
    threat_tags: List[str] = field(default_factory=list)

@dataclass
class OSINTDomainReputation:
    """OSINT Domain Reputation"""
    domain: str = ""
    otx_malicious: bool = False
    virustotal_malicious: int = 0
    virustotal_total: int = 0
    spamhaus_listed: bool = False
    google_safe_browsing_threat: bool = False
    overall_threat_score: int = 0
    threat_tags: List[str] = field(default_factory=list)

@dataclass
class OSINTURLReputation:
    """OSINT URL Reputation"""
    url: str = ""
    virustotal_malicious: int = 0
    virustotal_total: int = 0
    google_safe_browsing_threat: bool = False
    ipqs_phishing: bool = False
    overall_threat_score: int = 0
    threat_tags: List[str] = field(default_factory=list)

@dataclass
class OSINTAnalysisResult:
    """OSINT Analysis Result"""
    timestamp: str = ""
    ip_reputations: List[OSINTIPReputation] = field(default_factory=list)
    domain_reputations: List[OSINTDomainReputation] = field(default_factory=list)
    url_reputations: List[OSINTURLReputation] = field(default_factory=list)
    overall_threat_level: str = "unknown"
    total_threat_indicators: int = 0
    high_confidence_threats: List[str] = field(default_factory=list)

@dataclass
class PhishingAnalysisResult:
    analysis_id: str = ""
    timestamp: str = ""
    source_file: str = ""
    header_analysis: HeaderAnalysis = field(default_factory=HeaderAnalysis)
    url_analyses: List[URLAnalysis] = field(default_factory=list)
    content_analysis: ContentAnalysis = field(default_factory=ContentAnalysis)
    attachment_analyses: List[AttachmentAnalysis] = field(default_factory=list)
    osint_analysis: OSINTAnalysisResult = field(default_factory=OSINTAnalysisResult)  # NEU v2.3.0
    ai_analysis: str = ""
    overall_risk_score: int = 0
    verdict: str = "unknown"
    iocs: Dict = field(default_factory=dict)

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

def load_cfg() -> dict:
    """Lade Konfiguration aus YAML"""
    cfg_path = os.path.join(CONFIG_DIR, "config.yaml")
    if not os.path.exists(cfg_path):
        # Fallback auf altes Format
        cfg_path = os.path.join(BASE, "config.yaml")

    with open(cfg_path, 'r') as f:
        return yaml.safe_load(f)

def get_file_hash(filepath: str) -> str:
    """Berechne SHA256 Hash"""
    sha256 = hashlib.sha256()
    with open(filepath, 'rb') as f:
        for chunk in iter(lambda: f.read(8192), b''):
            sha256.update(chunk)
    return sha256.hexdigest()

def detect_file_type_by_magic(filepath: str) -> str:
    """Erkenne Dateityp anhand Magic Bytes"""
    try:
        with open(filepath, 'rb') as f:
            header = f.read(16)

        if header.startswith(b'MZ'):
            return 'exe'
        elif header.startswith(b'\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1'):
            return 'ole'  # MSG, DOC, XLS
        elif header.startswith(b'PK'):
            # Check for OOXML (docx, xlsx, pptx) vs regular ZIP
            return 'zip'
        elif header.startswith(b'Rar!'):
            return 'rar'
        elif header.startswith(b"7z\xbc\xaf'\x1c"):
            return '7z'
        elif header.startswith(b'%PDF'):
            return 'pdf'
        elif b'From:' in header or b'Received:' in header:
            return 'eml'

        return 'unknown'
    except:
        return 'unknown'

def is_allowed(filepath: str, cfg: dict) -> bool:
    """Pr√ºfe ob Datei analysiert werden soll (Extension + Magic Bytes)"""
    allowed = cfg.get("attachments", {}).get("allowed_extensions", [])
    ext = os.path.splitext(filepath)[1].lower().lstrip('.')

    # 1. Extension Check
    if ext in allowed:
        return True

    # 2. Magic Bytes Check f√ºr Dateien ohne/mit falscher Extension
    magic_type = detect_file_type_by_magic(filepath)

    if magic_type == 'exe' and ('exe' in allowed or 'dll' in allowed):
        logger.debug(f"EXE via Magic Bytes erkannt: {filepath}")
        return True
    elif magic_type == 'ole' and ('msg' in allowed or 'doc' in allowed):
        logger.debug(f"OLE (MSG/DOC) via Magic Bytes erkannt: {filepath}")
        return True
    elif magic_type == 'zip' and 'zip' in allowed:
        return True
    elif magic_type == 'pdf' and 'pdf' in allowed:
        return True

    return False

def extract_password_from_text(text: str) -> Optional[str]:
    """Extrahiere Passwort aus Mail-Body"""
    patterns = [
        r'(?:passwort|password|pw|kennwort)[:\s]+["\']?([^\s"\'<>]+)["\']?',
        r'(?:entpacken|extract|unzip)\s+(?:mit|with)[:\s]+["\']?([^\s"\'<>]+)["\']?',
    ]

    for pattern in patterns:
        match = re.search(pattern, text, re.IGNORECASE)
        if match:
            return match.group(1)

    return None

def try_extract_archive(archive_path: str, dest_dir: str, password: Optional[str] = None) -> List[str]:
    """Versuche Archiv zu entpacken"""
    extracted = []
    ext = os.path.splitext(archive_path)[1].lower()

    passwords_to_try = [password] if password else []
    passwords_to_try.extend(DEFAULT_PASSWORDS)

    for pwd in passwords_to_try:
        try:
            if ext == '.zip':
                with pyzipper.AESZipFile(archive_path, 'r') as zf:
                    pwd_bytes = pwd.encode() if pwd else None
                    zf.extractall(dest_dir, pwd=pwd_bytes)
                    extracted = [os.path.join(dest_dir, n) for n in zf.namelist()]
                    break
            elif ext == '.7z':
                cmd = ['7z', 'x', f'-p{pwd}' if pwd else '', '-y', f'-o{dest_dir}', archive_path]
                result = subprocess.run(cmd, capture_output=True, timeout=60)
                if result.returncode == 0:
                    extracted = [os.path.join(dest_dir, f) for f in os.listdir(dest_dir)]
                    break
            elif ext == '.rar':
                cmd = ['unrar', 'x', f'-p{pwd}' if pwd else '', '-y', archive_path, dest_dir]
                result = subprocess.run(cmd, capture_output=True, timeout=60)
                if result.returncode == 0:
                    extracted = [os.path.join(dest_dir, f) for f in os.listdir(dest_dir)]
                    break
        except Exception as e:
            logger.debug(f"Entpacken mit Passwort '{pwd}' fehlgeschlagen: {e}")
            continue

    return extracted

# =============================================================================
# SERVICE AVAILABILITY CHECKS
# =============================================================================

def check_ollama_available(cfg: dict) -> bool:
    """Pr√ºfe ob Ollama erreichbar ist"""
    try:
        host = cfg.get("ollama", {}).get("host", "http://localhost:11434")
        r = requests.get(f"{host}/api/tags", timeout=5)
        return r.status_code == 200
    except:
        return False

def check_cape_available() -> bool:
    """Pr√ºfe ob CAPE API erreichbar ist"""
    try:
        r = requests.get("http://127.0.0.1:8000/apiv2/cuckoo/status/", timeout=5)
        return r.status_code == 200
    except:
        return False

# =============================================================================
# HEADER ANALYZER (Enhanced v2.0)
# =============================================================================

class ImprovedHeaderAnalyzer:
    """
    Verbesserte Header-Analyse v2.0
    - Multi-Source SPF/DKIM/DMARC Parsing
    - Detaillierte Mail-Routing-Analyse
    - TLS/Cipher-Erkennung
    - ARC-Support
    - Security-Recommendations
    """

    IP_PATTERNS = [
        r'\[(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\]',
        r'\((\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\)',
        r'from\s+\S+\s+\(.*?(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})',
        r'by\s+\S+.*?with.*?id.*?for.*?(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})',
        r'client-ip=(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})',
        r'sender\s+ip\s+is\s+(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})',
        r'helo=.*?(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})',
    ]

    SECURITY_SYSTEMS = {
        'sophos': ['sophos', 'sasi', 'pmx'],
        'proofpoint': ['proofpoint', 'ppops'],
        'mimecast': ['mimecast'],
        'barracuda': ['barracuda', 'bsf'],
        'fortimail': ['fortimail', 'fortinet'],
        'cisco_esa': ['cisco', 'ironport', 'esa'],
        'microsoft_atp': ['microsoft', 'x-ms-exchange', 'atp', 'exchange online protection'],
        'google': ['google', 'gmail'],
        'spamassassin': ['spamassassin', 'spamd'],
        'amazon_ses': ['amazonses', 'smtp-out.amazonses'],  # NEU
        'postfix': ['postfix'],  # NEU
        'exim': ['exim'],  # NEU
    }

    HIGH_RISK_COUNTRIES = ['RU', 'CN', 'KP', 'IR', 'NG', 'UA', 'BY']

    # Weak TLS/Cipher Patterns
    WEAK_TLS = ['SSLv2', 'SSLv3', 'TLSv1', 'TLS1_0', 'TLS1_1']
    WEAK_CIPHERS = ['RC4', 'DES', 'MD5', '3DES', 'CBC']

    def __init__(self, msg, otx_client=None):
        self.msg = msg
        self.otx = otx_client
        self.result = HeaderAnalysis()

    def analyze(self) -> HeaderAnalysis:
        """F√ºhre vollst√§ndige Header-Analyse durch"""
        self._extract_basic_headers()
        self._analyze_authentication_multi_source()  # NEU: Multi-Source
        self._analyze_received_chain()
        self._analyze_routing_security()  # NEU: Routing-Analyse
        self._detect_security_systems()
        self._detect_anomalies()
        self._generate_recommendations()  # NEU: Security-Recommendations
        self._calculate_risk_score()
        return self.result

    def _extract_basic_headers(self):
        """Extrahiere Basis-Header"""
        self.result.from_address = self._get_header('From', '')
        self.result.reply_to = self._get_header('Reply-To', '')
        self.result.return_path = self._get_header('Return-Path', '')
        self.result.subject = self._get_header('Subject', '')
        self.result.date = self._get_header('Date', '')
        self.result.message_id = self._get_header('Message-ID', '')

        # X-Originating-IP
        for header in ['X-Originating-IP', 'X-Sender-IP', 'X-Source-IP']:
            ip = self._get_header(header, '')
            if ip:
                self.result.originating_ip = ip.strip('[]')
                break

        # Parse From Display Name
        from_header = self.result.from_address
        if '<' in from_header:
            self.result.from_display = from_header.split('<')[0].strip().strip('"')
            self.result.from_address = from_header.split('<')[1].rstrip('>')

    def _get_header(self, name: str, default: str = '') -> str:
        """Hole Header-Wert sicher"""
        try:
            value = self.msg.get(name, default)
            if value:
                return str(value)
            return default
        except:
            return default

    def _analyze_authentication_multi_source(self):
        """
        NEU: Multi-Source SPF/DKIM/DMARC Parsing
        Priorisierung:
        1. Authentication-Results (Standard)
        2. Received-SPF (RFC 7208)
        3. X-MS-Exchange-Organization-* (Microsoft)
        4. ARC-Authentication-Results
        """
        
        # === SPF ===
        spf_result = "none"
        spf_source = "none"

        # 1. Authentication-Results
        auth_results = self._get_header('Authentication-Results', '')
        if auth_results:
            spf_match = re.search(r'spf=(\w+)', auth_results, re.I)
            if spf_match:
                spf_result = spf_match.group(1).lower()
                spf_source = "Authentication-Results"

        # 2. Received-SPF (lowercase/uppercase)
        if spf_result == "none":
            received_spf = self._get_header('received-spf', '') or self._get_header('Received-SPF', '')
            if received_spf:
                spf_source = "Received-SPF"
                received_spf_clean = received_spf.strip().lower()
                
                if received_spf_clean.startswith('pass'):
                    spf_result = 'pass'
                elif received_spf_clean.startswith('fail'):
                    spf_result = 'fail'
                elif received_spf_clean.startswith('softfail'):
                    spf_result = 'softfail'
                elif received_spf_clean.startswith('neutral'):
                    spf_result = 'neutral'
                elif received_spf_clean.startswith('none'):
                    spf_result = 'none'
                elif 'temperror' in received_spf_clean or 'temp' in received_spf_clean:
                    spf_result = 'temperror'
                elif 'permerror' in received_spf_clean or 'perm' in received_spf_clean:
                    spf_result = 'permerror'

        # 3. Microsoft Exchange SenderID
        if spf_result == "none":
            ms_sender_id = self._get_header('X-MS-Exchange-Organization-SenderIdResult', '')
            if ms_sender_id:
                spf_result = ms_sender_id.lower()
                spf_source = "X-MS-Exchange-SenderIdResult"

        self.result.spf_result = spf_result
        self.result.spf_source = spf_source

        # === DKIM ===
        dkim_result = "none"
        dkim_source = "none"

        # 1. Authentication-Results
        if auth_results:
            dkim_match = re.search(r'dkim=(\w+)', auth_results, re.I)
            if dkim_match:
                dkim_result = dkim_match.group(1).lower()
                dkim_source = "Authentication-Results"

        # 2. DKIM-Signature vorhanden?
        if dkim_result == "none":
            dkim_sig = self._get_header('DKIM-Signature', '')
            if dkim_sig:
                # Signatur vorhanden, aber kein Validierungsergebnis
                dkim_result = "unsigned"  # Marker f√ºr "nicht validiert"
                dkim_source = "DKIM-Signature (not validated)"

        # 3. ARC-Authentication-Results
        if dkim_result == "none":
            arc_auth = self._get_header('ARC-Authentication-Results', '')
            if arc_auth:
                dkim_match = re.search(r'dkim=(\w+)', arc_auth, re.I)
                if dkim_match:
                    dkim_result = dkim_match.group(1).lower()
                    dkim_source = "ARC-Authentication-Results"

        self.result.dkim_result = dkim_result
        self.result.dkim_source = dkim_source

        # === DMARC ===
        dmarc_result = "none"
        dmarc_source = "none"

        # 1. Authentication-Results
        if auth_results:
            dmarc_match = re.search(r'dmarc=(\w+)', auth_results, re.I)
            if dmarc_match:
                dmarc_result = dmarc_match.group(1).lower()
                dmarc_source = "Authentication-Results"

        # 2. ARC-Authentication-Results
        if dmarc_result == "none":
            arc_auth = self._get_header('ARC-Authentication-Results', '')
            if arc_auth:
                dmarc_match = re.search(r'dmarc=(\w+)', arc_auth, re.I)
                if dmarc_match:
                    dmarc_result = dmarc_match.group(1).lower()
                    dmarc_source = "ARC-Authentication-Results"

        self.result.dmarc_result = dmarc_result
        self.result.dmarc_source = dmarc_source

        logger.debug(f"‚úÖ Auth-Parsing: SPF={spf_result} ({spf_source}), DKIM={dkim_result} ({dkim_source}), DMARC={dmarc_result} ({dmarc_source})")

    def _analyze_received_chain(self):
        """Analysiere Received-Header-Kette (Legacy f√ºr IOC-Extraktion)"""
        received_headers = self.msg.get_all('Received', [])

        for i, header in enumerate(received_headers):
            header_str = str(header)
            hop_info = {'raw': header_str[:200], 'ips': []}

            # IPs extrahieren
            for pattern in self.IP_PATTERNS:
                matches = re.findall(pattern, header_str, re.I)
                for ip in matches:
                    if self._is_valid_public_ip(ip):
                        hop_info['ips'].append(ip)
                        if not self.result.originating_ip and i == len(received_headers) - 1:
                            self.result.originating_ip = ip

            self.result.received_chain.append(hop_info)

    def _analyze_routing_security(self):
        """
        NEU: Detaillierte Mail-Routing-Analyse
        - TLS-Versionen und Cipher-Suites
        - ARC-Header-Pr√§senz
        - Security-Issues
        """
        routing = MailRoutingAnalysis()
        received_headers = self.msg.get_all('Received', [])
        routing.total_hops = len(received_headers)

        for i, header in enumerate(received_headers):
            header_str = str(header).replace('\n', ' ').replace('\r', '')
            
            hop = MailHop(
                index=i + 1,
                raw_header=header_str[:200]
            )

            # From/To Server
            from_match = re.search(r'from\s+([\w\.\-]+)', header_str, re.I)
            if from_match:
                hop.from_server = from_match.group(1)

            by_match = re.search(r'by\s+([\w\.\-]+)', header_str, re.I)
            if by_match:
                hop.to_server = by_match.group(1)

            # IPs
            for pattern in self.IP_PATTERNS:
                matches = re.findall(pattern, header_str)
                hop.ips.extend([ip for ip in matches if self._is_valid_public_ip(ip)])

            # TLS Version
            tls_match = re.search(r'version=(TLS[\d_]+|SSLv\d)', header_str, re.I)
            if tls_match:
                hop.tls_version = tls_match.group(1)
                routing.uses_tls = True
                
                # Weak TLS Check
                if any(weak in hop.tls_version for weak in self.WEAK_TLS):
                    routing.weak_tls = True
                    routing.security_issues.append(f"Hop {i+1}: Weak TLS ({hop.tls_version})")

            # Cipher Suite
            cipher_match = re.search(r'cipher=([\w\-_]+)', header_str, re.I)
            if cipher_match:
                hop.cipher = cipher_match.group(1)
                
                # Weak Cipher Check
                if any(weak in hop.cipher for weak in self.WEAK_CIPHERS):
                    routing.weak_cipher = True
                    routing.security_issues.append(f"Hop {i+1}: Weak Cipher ({hop.cipher})")

            # Protocol
            proto_match = re.search(r'with\s+(ESMTPS?|SMTP|LMTP)', header_str, re.I)
            if proto_match:
                hop.protocol = proto_match.group(1)

            routing.hops.append(hop)

        # ARC-Header Check
        arc_headers = [k for k in self.msg.keys() if k.startswith('ARC-')]
        routing.has_arc = len(arc_headers) > 0

        if not routing.has_arc and routing.total_hops > 3:
            routing.security_issues.append("No ARC headers in multi-hop chain")

        self.result.routing_analysis = routing

    def _is_valid_public_ip(self, ip: str) -> bool:
        """Pr√ºfe ob IP √∂ffentlich ist"""
        try:
            addr = ipaddress.ip_address(ip)
            return not (addr.is_private or addr.is_loopback or addr.is_reserved)
        except:
            return False

    def _detect_security_systems(self):
        """Erkenne Security-Systeme in der Mail-Kette"""
        all_headers_str = str(self.msg).lower()

        for system, keywords in self.SECURITY_SYSTEMS.items():
            for keyword in keywords:
                if keyword.lower() in all_headers_str:
                    if system not in self.result.security_systems:
                        self.result.security_systems.append(system)
                    break

    def _detect_anomalies(self):
        """Erkenne Header-Anomalien"""
        # From/Reply-To Mismatch
        if self.result.reply_to and self.result.from_address:
            from_domain = self.result.from_address.split('@')[-1].lower() if '@' in self.result.from_address else ''
            
            # Reply-To kann <...> enthalten
            reply_to_clean = self.result.reply_to
            if '<' in reply_to_clean:
                reply_to_clean = reply_to_clean.split('<')[-1].rstrip('>')
            
            reply_domain = reply_to_clean.split('@')[-1].lower() if '@' in reply_to_clean else ''
            
            if from_domain and reply_domain and from_domain != reply_domain:
                self.result.anomalies.append(f"From/Reply-To Domain Mismatch: {from_domain} vs {reply_domain}")

        # Display Name Spoofing
        if self.result.from_display and self.result.from_address:
            if '@' in self.result.from_display:
                display_domain = self.result.from_display.split('@')[-1].lower()
                actual_domain = self.result.from_address.split('@')[-1].lower()
                if display_domain != actual_domain:
                    self.result.anomalies.append(f"Display Name Spoofing: {self.result.from_display}")

        # Failed Authentication
        if self.result.spf_result in ['fail', 'softfail']:
            self.result.anomalies.append(f"SPF {self.result.spf_result} ({self.result.spf_source})")
        elif self.result.spf_result in ['temperror', 'permerror']:
            self.result.anomalies.append(f"SPF {self.result.spf_result} ({self.result.spf_source})")
            
        if self.result.dkim_result == 'fail':
            self.result.anomalies.append(f"DKIM fail ({self.result.dkim_source})")
            
        if self.result.dmarc_result == 'fail':
            self.result.anomalies.append(f"DMARC fail ({self.result.dmarc_source})")

    def _generate_recommendations(self):
        """
        NEU: Generiere Security-Recommendations f√ºr Mail-Gateway-Tuning
        """
        recommendations = []

        # SPF Issues
        if self.result.spf_result in ['none', 'temperror', 'permerror', 'fail', 'softfail']:
            recommendations.append({
                'system': 'Mail Gateway (SPF)',
                'issue': f'SPF Result: {self.result.spf_result}',
                'severity': 'high' if self.result.spf_result in ['fail', 'softfail'] else 'medium',
                'recommendation': 'Enable SPF validation with reject/quarantine policy',
                'config_postfix': 'smtpd_recipient_restrictions = reject_unauth_pipelining, reject_unverified_sender',
                'config_rspamd': 'spf { enabled = true; }',
            })

        # DKIM Issues
        if self.result.dkim_result in ['none', 'unsigned']:
            recommendations.append({
                'system': 'Mail Gateway (DKIM)',
                'issue': 'No DKIM validation detected',
                'severity': 'high',
                'recommendation': 'Enable DKIM signature verification',
                'config_postfix': 'Install opendkim: apt-get install opendkim opendkim-tools',
                'config_rspamd': 'dkim { enabled = true; }',
            })

        # DMARC Issues
        if self.result.dmarc_result == 'none':
            recommendations.append({
                'system': 'Mail Gateway (DMARC)',
                'issue': 'No DMARC validation detected',
                'severity': 'high',
                'recommendation': 'Enable DMARC policy enforcement',
                'config_postfix': 'Install opendmarc: apt-get install opendmarc',
                'config_rspamd': 'dmarc { enabled = true; }',
            })

        # ARC Missing
        routing = self.result.routing_analysis
        if not routing.has_arc and routing.total_hops > 2:
            recommendations.append({
                'system': 'Microsoft Exchange / Mail Gateway',
                'issue': 'No ARC (Authenticated Received Chain) headers',
                'severity': 'medium',
                'recommendation': 'Enable ARC sealing to preserve authentication through forwarding',
                'config_exchange': 'Set-TransportConfig -ARCTrustedSealers @{Add="domain.com"}',
                'config_rspamd': 'arc { enabled = true; mode = "sign"; }',
            })

        # Weak TLS
        if routing.weak_tls:
            recommendations.append({
                'system': 'SMTP Servers (TLS)',
                'issue': f'Weak TLS versions detected: {routing.security_issues}',
                'severity': 'high',
                'recommendation': 'Enforce TLS 1.2+ only, disable TLS 1.0/1.1',
                'config_postfix': 'smtpd_tls_mandatory_protocols = !SSLv2,!SSLv3,!TLSv1,!TLSv1.1',
                'config_exchange': 'Set TLS minimum version to 1.2 in EAC',
            })

        # Weak Ciphers
        if routing.weak_cipher:
            recommendations.append({
                'system': 'SMTP Servers (Ciphers)',
                'issue': 'Weak cipher suites detected',
                'severity': 'medium',
                'recommendation': 'Use modern cipher suites only (AES-GCM, ChaCha20)',
                'config_postfix': 'smtpd_tls_mandatory_ciphers = high',
                'config_nginx': 'ssl_ciphers HIGH:!aNULL:!MD5:!RC4:!3DES;',
            })

        # Missing Security Systems
        if 'spamassassin' not in self.result.security_systems and 'microsoft_atp' not in self.result.security_systems:
            recommendations.append({
                'system': 'Mail Gateway (Content Filtering)',
                'issue': 'No advanced threat protection detected',
                'severity': 'high',
                'recommendation': 'Deploy content filtering (SpamAssassin, rspamd, or commercial ATP)',
                'config_debian': 'apt-get install spamassassin rspamd',
            })

        self.result.routing_analysis.recommendations = recommendations

    def _calculate_risk_score(self):
        """Berechne Risiko-Score"""
        score = 0

        # Authentication failures (Gewichtung nach Severity)
        if self.result.spf_result == 'fail':
            score += 25
        elif self.result.spf_result == 'softfail':
            score += 15
        elif self.result.spf_result in ['temperror', 'permerror']:
            score += 10

        if self.result.dkim_result == 'fail':
            score += 20
        elif self.result.dkim_result in ['none', 'unsigned']:
            score += 5

        if self.result.dmarc_result == 'fail':
            score += 20
        elif self.result.dmarc_result == 'none':
            score += 5

        # Anomalies
        score += len(self.result.anomalies) * 10

        # Routing Security Issues
        score += len(self.result.routing_analysis.security_issues) * 5

        self.result.risk_score = min(score, 100)


# =============================================================================
# OSINT ANALYZER
# =============================================================================

class OSINTAnalyzer:
    """Multi-Source OSINT Threat Intelligence Analyzer"""
    
    def __init__(self, cfg: dict):
        self.cfg = cfg.get('osint', {})
        self.otx_cfg = self.cfg.get('otx', {})
        self.abuseipdb_cfg = self.cfg.get('abuseipdb', {})
        self.vt_cfg = self.cfg.get('virustotal', {})
        self.urlscan_cfg = self.cfg.get('urlscan', {})
        self.gsb_cfg = self.cfg.get('google_safe_browsing', {})
        self.spamhaus_cfg = self.cfg.get('spamhaus', {})
        self.ipqs_cfg = self.cfg.get('ipqualityscore', {})
    
    def analyze_all(self, ips: List[str], domains: List[str], urls: List[str]) -> OSINTAnalysisResult:
        """F√ºhre vollst√§ndige OSINT-Analyse durch"""
        result = OSINTAnalysisResult(timestamp=datetime.now().isoformat())
        
        ips = list(set(ips))[:10]
        domains = list(set(domains))[:10]
        urls = list(set(urls))[:20]
        
        logger.info(f"üîç OSINT-Analyse: {len(ips)} IPs, {len(domains)} Domains, {len(urls)} URLs")
        
        with ThreadPoolExecutor(max_workers=5) as executor:
            ip_futures = {executor.submit(self.analyze_ip, ip): ip for ip in ips}
            for future in as_completed(ip_futures):
                try:
                    ip_result = future.result()
                    if ip_result:
                        result.ip_reputations.append(ip_result)
                except Exception as e:
                    logger.debug(f"IP-OSINT fehlgeschlagen: {e}")
            
            domain_futures = {executor.submit(self.analyze_domain, domain): domain for domain in domains}
            for future in as_completed(domain_futures):
                try:
                    domain_result = future.result()
                    if domain_result:
                        result.domain_reputations.append(domain_result)
                except Exception as e:
                    logger.debug(f"Domain-OSINT fehlgeschlagen: {e}")
            
            url_futures = {executor.submit(self.analyze_url, url): url for url in urls}
            for future in as_completed(url_futures):
                try:
                    url_result = future.result()
                    if url_result:
                        result.url_reputations.append(url_result)
                except Exception as e:
                    logger.debug(f"URL-OSINT fehlgeschlagen: {e}")
        
        self._calculate_overall_threat(result)
        logger.info(f"‚úÖ OSINT: {result.total_threat_indicators} Threats, Level={result.overall_threat_level}")
        
        return result
    
    def analyze_ip(self, ip: str) -> Optional[OSINTIPReputation]:
        """Analysiere IP via OSINT-Quellen"""
        result = OSINTIPReputation(ip=ip)
        
        try:
            # AlienVault OTX
            if self.otx_cfg.get('enabled'):
                otx_data = self._check_otx_ip(ip)
                if otx_data:
                    result.otx_pulses = otx_data.get('pulses', [])[:5]
                    result.otx_malicious = otx_data.get('pulse_count', 0) > 0
                    if result.otx_malicious:
                        result.threat_tags.append(f"OTX: {otx_data.get('pulse_count')} pulses")
            
            # AbuseIPDB
            if self.abuseipdb_cfg.get('enabled') and self.abuseipdb_cfg.get('api_key'):
                abuse_data = self._check_abuseipdb(ip)
                if abuse_data:
                    result.abuseipdb_score = abuse_data.get('abuseConfidenceScore', 0)
                    if result.abuseipdb_score > 50:
                        result.threat_tags.append(f"AbuseIPDB: {result.abuseipdb_score}%")
            
            # VirusTotal
            if self.vt_cfg.get('enabled') and self.vt_cfg.get('api_key'):
                vt_data = self._check_virustotal_ip(ip)
                if vt_data:
                    stats = vt_data.get('attributes', {}).get('last_analysis_stats', {})
                    result.virustotal_malicious = stats.get('malicious', 0)
                    result.virustotal_total = sum(stats.values())
                    if result.virustotal_malicious > 0:
                        result.threat_tags.append(f"VT: {result.virustotal_malicious}/{result.virustotal_total}")
            
            # Spamhaus (DNS-based, kostenlos)
            if self.spamhaus_cfg.get('enabled', True):
                if self._check_spamhaus_ip(ip):
                    result.spamhaus_listed = True
                    result.threat_tags.append("Spamhaus: Listed")
            
            # IPQualityScore
            if self.ipqs_cfg.get('enabled') and self.ipqs_cfg.get('api_key'):
                ipqs_data = self._check_ipqs_ip(ip)
                if ipqs_data:
                    result.ipqs_fraud_score = ipqs_data.get('fraud_score', 0)
                    if result.ipqs_fraud_score > 75:
                        result.threat_tags.append(f"IPQS: {result.ipqs_fraud_score}%")
            
            result.overall_threat_score = self._calculate_ip_threat_score(result)
            return result
        
        except Exception as e:
            logger.debug(f"IP-OSINT fehlgeschlagen f√ºr {ip}: {e}")
            return None
    
    def analyze_domain(self, domain: str) -> Optional[OSINTDomainReputation]:
        """Analysiere Domain"""
        result = OSINTDomainReputation(domain=domain)
        
        try:
            if self.otx_cfg.get('enabled'):
                otx_data = self._check_otx_domain(domain)
                if otx_data and otx_data.get('pulse_count', 0) > 0:
                    result.otx_malicious = True
                    result.threat_tags.append(f"OTX: {otx_data.get('pulse_count')} pulses")
            
            if self.vt_cfg.get('enabled') and self.vt_cfg.get('api_key'):
                vt_data = self._check_virustotal_domain(domain)
                if vt_data:
                    stats = vt_data.get('attributes', {}).get('last_analysis_stats', {})
                    result.virustotal_malicious = stats.get('malicious', 0)
                    result.virustotal_total = sum(stats.values())
                    if result.virustotal_malicious > 0:
                        result.threat_tags.append(f"VT: {result.virustotal_malicious}/{result.virustotal_total}")
            
            if self.spamhaus_cfg.get('enabled', True):
                if self._check_spamhaus_domain(domain):
                    result.spamhaus_listed = True
                    result.threat_tags.append("Spamhaus: DBL listed")
            
            if self.gsb_cfg.get('enabled') and self.gsb_cfg.get('api_key'):
                gsb_data = self._check_google_safe_browsing(f"http://{domain}")
                if gsb_data:
                    result.google_safe_browsing_threat = True
                    result.threat_tags.append(f"GSB: {', '.join(gsb_data)}")
            
            result.overall_threat_score = self._calculate_domain_threat_score(result)
            return result
        
        except Exception as e:
            logger.debug(f"Domain-OSINT fehlgeschlagen: {e}")
            return None
    
    def analyze_url(self, url: str) -> Optional[OSINTURLReputation]:
        """Analysiere URL"""
        result = OSINTURLReputation(url=url)
        
        try:
            if self.vt_cfg.get('enabled') and self.vt_cfg.get('api_key'):
                vt_data = self._check_virustotal_url(url)
                if vt_data:
                    stats = vt_data.get('attributes', {}).get('last_analysis_stats', {})
                    result.virustotal_malicious = stats.get('malicious', 0)
                    result.virustotal_total = sum(stats.values())
                    if result.virustotal_malicious > 0:
                        result.threat_tags.append(f"VT: {result.virustotal_malicious}/{result.virustotal_total}")
            
            if self.gsb_cfg.get('enabled') and self.gsb_cfg.get('api_key'):
                gsb_data = self._check_google_safe_browsing(url)
                if gsb_data:
                    result.google_safe_browsing_threat = True
                    result.threat_tags.append(f"GSB: {', '.join(gsb_data)}")
            
            if self.ipqs_cfg.get('enabled') and self.ipqs_cfg.get('api_key'):
                ipqs_data = self._check_ipqs_url(url)
                if ipqs_data:
                    result.ipqs_phishing = ipqs_data.get('phishing', False)
                    if result.ipqs_phishing:
                        result.threat_tags.append("IPQS: Phishing")
            
            result.overall_threat_score = self._calculate_url_threat_score(result)
            return result
        
        except Exception as e:
            logger.debug(f"URL-OSINT fehlgeschlagen: {e}")
            return None
    
    # API-Check-Methoden (kompakt)
    def _check_otx_ip(self, ip: str) -> Optional[Dict]:
        try:
            api_key = self.otx_cfg.get('api_key')
            if not api_key: return None
            r = requests.get(f"https://otx.alienvault.com/api/v1/indicators/IPv4/{ip}/general",
                           headers={'X-OTX-API-KEY': api_key}, timeout=self.otx_cfg.get('timeout', 10))
            if r.status_code == 200:
                data = r.json()
                return {'pulse_count': data.get('pulse_info', {}).get('count', 0),
                       'pulses': [{'name': p.get('name')} for p in data.get('pulse_info', {}).get('pulses', [])]}
        except: pass
        return None
    
    def _check_otx_domain(self, domain: str) -> Optional[Dict]:
        try:
            api_key = self.otx_cfg.get('api_key')
            if not api_key: return None
            r = requests.get(f"https://otx.alienvault.com/api/v1/indicators/domain/{domain}/general",
                           headers={'X-OTX-API-KEY': api_key}, timeout=self.otx_cfg.get('timeout', 10))
            if r.status_code == 200:
                data = r.json()
                return {'pulse_count': data.get('pulse_info', {}).get('count', 0)}
        except: pass
        return None
    
    def _check_abuseipdb(self, ip: str) -> Optional[Dict]:
        try:
            api_key = self.abuseipdb_cfg.get('api_key')
            if not api_key: return None
            r = requests.get('https://api.abuseipdb.com/api/v2/check',
                           params={'ipAddress': ip, 'maxAgeInDays': self.abuseipdb_cfg.get('max_age_days', 90)},
                           headers={'Key': api_key}, timeout=self.abuseipdb_cfg.get('timeout', 10))
            if r.status_code == 200:
                return r.json().get('data', {})
        except: pass
        return None
    
    def _check_virustotal_ip(self, ip: str) -> Optional[Dict]:
        try:
            api_key = self.vt_cfg.get('api_key')
            if not api_key: return None
            r = requests.get(f"https://www.virustotal.com/api/v3/ip_addresses/{ip}",
                           headers={'x-apikey': api_key}, timeout=self.vt_cfg.get('timeout', 15))
            if r.status_code == 200:
                return r.json().get('data', {})
        except: pass
        return None
    
    def _check_virustotal_domain(self, domain: str) -> Optional[Dict]:
        try:
            api_key = self.vt_cfg.get('api_key')
            if not api_key: return None
            r = requests.get(f"https://www.virustotal.com/api/v3/domains/{domain}",
                           headers={'x-apikey': api_key}, timeout=self.vt_cfg.get('timeout', 15))
            if r.status_code == 200:
                return r.json().get('data', {})
        except: pass
        return None
    
    def _check_virustotal_url(self, url: str) -> Optional[Dict]:
        try:
            api_key = self.vt_cfg.get('api_key')
            if not api_key: return None
            import base64
            url_id = base64.urlsafe_b64encode(url.encode()).decode().rstrip('=')
            r = requests.get(f"https://www.virustotal.com/api/v3/urls/{url_id}",
                           headers={'x-apikey': api_key}, timeout=self.vt_cfg.get('timeout', 15))
            if r.status_code == 200:
                return r.json().get('data', {})
        except: pass
        return None
    
    def _check_google_safe_browsing(self, url: str) -> Optional[List[str]]:
        try:
            api_key = self.gsb_cfg.get('api_key')
            if not api_key: return None
            payload = {
                "client": {"clientId": "cape-mailer", "clientVersion": "2.3.0"},
                "threatInfo": {
                    "threatTypes": ["MALWARE", "SOCIAL_ENGINEERING"],
                    "platformTypes": ["ANY_PLATFORM"],
                    "threatEntryTypes": ["URL"],
                    "threatEntries": [{"url": url}]
                }
            }
            r = requests.post(f"https://safebrowsing.googleapis.com/v4/threatMatches:find?key={api_key}",
                            json=payload, timeout=self.gsb_cfg.get('timeout', 10))
            if r.status_code == 200:
                matches = r.json().get('matches', [])
                return [m.get('threatType') for m in matches] if matches else None
        except: pass
        return None
    
    def _check_spamhaus_ip(self, ip: str) -> bool:
        try:
            parts = ip.split('.')
            reversed_ip = '.'.join(reversed(parts))
            query = f"{reversed_ip}.zen.spamhaus.org"
            dns.resolver.resolve(query, 'A')
            return True
        except:
            return False
    
    def _check_spamhaus_domain(self, domain: str) -> bool:
        try:
            query = f"{domain}.dbl.spamhaus.org"
            dns.resolver.resolve(query, 'A')
            return True
        except:
            return False
    
    def _check_ipqs_ip(self, ip: str) -> Optional[Dict]:
        try:
            api_key = self.ipqs_cfg.get('api_key')
            if not api_key: return None
            r = requests.get(f"https://www.ipqualityscore.com/api/json/ip/{api_key}/{ip}",
                           timeout=self.ipqs_cfg.get('timeout', 10))
            if r.status_code == 200:
                return r.json()
        except: pass
        return None
    
    def _check_ipqs_url(self, url: str) -> Optional[Dict]:
        try:
            api_key = self.ipqs_cfg.get('api_key')
            if not api_key: return None
            from urllib.parse import quote
            r = requests.post(f"https://www.ipqualityscore.com/api/json/url/{api_key}/{quote(url, safe='')}",
                            timeout=self.ipqs_cfg.get('timeout', 10))
            if r.status_code == 200:
                return r.json()
        except: pass
        return None
    
    # Threat Score Calculation
    def _calculate_ip_threat_score(self, result: OSINTIPReputation) -> int:
        score = 0
        if result.otx_malicious: score += 30
        if result.abuseipdb_score > 75: score += 40
        elif result.abuseipdb_score > 50: score += 25
        if result.virustotal_malicious > 0:
            score += int((result.virustotal_malicious / max(result.virustotal_total, 1)) * 30)
        if result.spamhaus_listed: score += 35
        if result.ipqs_fraud_score > 75: score += 25
        return min(score, 100)
    
    def _calculate_domain_threat_score(self, result: OSINTDomainReputation) -> int:
        score = 0
        if result.otx_malicious: score += 30
        if result.virustotal_malicious > 0:
            score += int((result.virustotal_malicious / max(result.virustotal_total, 1)) * 40)
        if result.spamhaus_listed: score += 35
        if result.google_safe_browsing_threat: score += 40
        return min(score, 100)
    
    def _calculate_url_threat_score(self, result: OSINTURLReputation) -> int:
        score = 0
        if result.virustotal_malicious > 0:
            score += int((result.virustotal_malicious / max(result.virustotal_total, 1)) * 35)
        if result.google_safe_browsing_threat: score += 40
        if result.ipqs_phishing: score += 35
        return min(score, 100)
    
    def _calculate_overall_threat(self, result: OSINTAnalysisResult):
        """Berechne Gesamt-Threat-Level"""
        total_threats = 0
        high_confidence = []
        
        for ip_rep in result.ip_reputations:
            if ip_rep.overall_threat_score > 60:
                total_threats += 1
                high_confidence.append(f"IP {ip_rep.ip}: {', '.join(ip_rep.threat_tags)}")
        
        for domain_rep in result.domain_reputations:
            if domain_rep.overall_threat_score > 60:
                total_threats += 1
                high_confidence.append(f"Domain {domain_rep.domain}: {', '.join(domain_rep.threat_tags)}")
        
        for url_rep in result.url_reputations:
            if url_rep.overall_threat_score > 60:
                total_threats += 1
                high_confidence.append(f"URL {url_rep.url[:50]}...: {', '.join(url_rep.threat_tags)}")
        
        result.total_threat_indicators = total_threats
        result.high_confidence_threats = high_confidence
        
        if total_threats >= 3:
            result.overall_threat_level = "critical"
        elif total_threats >= 1:
            result.overall_threat_level = "high"
        elif any(ip.overall_threat_score > 30 for ip in result.ip_reputations) or \
             any(d.overall_threat_score > 30 for d in result.domain_reputations) or \
             any(u.overall_threat_score > 30 for u in result.url_reputations):
            result.overall_threat_level = "medium"
        else:
            result.overall_threat_level = "low"

# =============================================================================
# URL ANALYZER
# =============================================================================

class URLAnalyzer:
    """Analysiert URLs auf Phishing-Indikatoren"""

    def __init__(self, url: str, tor_proxy: str = TOR_PROXY):
        self.url = url
        self.tor_proxy = tor_proxy
        self.result = URLAnalysis(url=url)

    def analyze(self) -> URLAnalysis:
        """F√ºhre URL-Analyse durch"""
        parsed = urlparse(self.url)
        self.result.domain = parsed.netloc.lower()

        self._check_typosquatting()
        self._check_reachability()

        return self.result

    def _check_typosquatting(self):
        """Pr√ºfe auf Typosquatting deutscher Banken"""
        domain = self.result.domain.lower()

        for bank in GERMAN_BANKS:
            bank_clean = bank.replace(' ', '').replace('-', '')
            domain_clean = domain.replace('-', '').replace('.', '')

            # Levenshtein-√§hnliche Pr√ºfung
            if bank_clean in domain_clean and bank_clean != domain_clean:
                self.result.is_typosquatting = True
                self.result.typosquatting_target = bank
                self.result.risk_reasons.append(f"M√∂gliches Typosquatting: {bank}")
                self.result.url_risk_score += 30
                break

    def _check_reachability(self):
        """Pr√ºfe URL-Erreichbarkeit via Tor"""
        try:
            proxies = {'http': self.tor_proxy, 'https': self.tor_proxy}
            r = requests.get(self.url, proxies=proxies, timeout=15, verify=False,
                           allow_redirects=True, headers={'User-Agent': 'Mozilla/5.0'})

            self.result.is_reachable = True
            self.result.final_url = r.url

            # Login-Form Detection
            if BeautifulSoup:
                soup = BeautifulSoup(r.text, 'html.parser')
                password_fields = soup.find_all('input', {'type': 'password'})
                if password_fields:
                    self.result.has_login_form = True
                    self.result.risk_reasons.append("Login-Formular gefunden")
                    self.result.url_risk_score += 20

        except Exception as e:
            logger.debug(f"URL nicht erreichbar: {self.url} - {e}")

# =============================================================================
# CONTENT ANALYZER
# =============================================================================

class ContentAnalyzer:
    """Analysiert Mail-Inhalt auf Phishing-Indikatoren"""

    IBAN_PATTERN = r'[A-Z]{2}\d{2}[\s]?(?:\d{4}[\s]?){4}\d{2}'
    URL_PATTERN = r'https?://[^\s<>"{}|\\^`\[\]]+'

    def __init__(self, text: str, html: str = ""):
        self.text = text
        self.html = html
        self.result = ContentAnalysis()

    def analyze(self) -> ContentAnalysis:
        """F√ºhre Content-Analyse durch"""
        combined = f"{self.text} {self.html}"

        self._extract_urls()
        self._extract_ibans()
        self._check_ceo_fraud()
        self._check_bank_mentions()
        self._calculate_urgency()
        self._check_tracking_pixels()

        return self.result

    def _extract_urls(self):
        """Extrahiere URLs"""
        combined = f"{self.text} {self.html}"
        urls = re.findall(self.URL_PATTERN, combined)
        self.result.extracted_urls = list(set(urls))[:50]  # Max 50 URLs

    def _extract_ibans(self):
        """Extrahiere und maskiere IBANs (DSGVO)"""
        ibans = re.findall(self.IBAN_PATTERN, self.text + self.html)
        # Maskierung: DE12****1234
        masked = []
        for iban in set(ibans):
            clean = iban.replace(' ', '')
            masked.append(f"{clean[:4]}****{clean[-4:]}")
        self.result.extracted_ibans = masked

    def _check_ceo_fraud(self):
        """Pr√ºfe auf CEO-Fraud-Indikatoren"""
        combined = (self.text + self.html).lower()
        for keyword in CEO_FRAUD_KEYWORDS:
            if keyword.lower() in combined:
                self.result.ceo_fraud_indicators.append(keyword)
                self.result.content_risk_score += 5

    def _check_bank_mentions(self):
        """Pr√ºfe auf Bank-Erw√§hnungen"""
        combined = (self.text + self.html).lower()
        for bank in GERMAN_BANKS:
            if bank.lower() in combined:
                self.result.bank_mentions.append(bank)

    def _calculate_urgency(self):
        """Berechne Urgency-Score"""
        urgency_words = ['dringend', 'sofort', 'urgent', 'immediately', 'asap',
                        'wichtig', 'critical', 'action required', 'handlungsbedarf']
        combined = (self.text + self.html).lower()

        for word in urgency_words:
            if word in combined:
                self.result.urgency_score += 10

        self.result.urgency_score = min(self.result.urgency_score, 100)

    def _check_tracking_pixels(self):
        """Pr√ºfe auf Tracking-Pixel"""
        if BeautifulSoup and self.html:
            soup = BeautifulSoup(self.html, 'html.parser')
            imgs = soup.find_all('img')
            for img in imgs:
                src = img.get('src', '')
                width = img.get('width', '')
                height = img.get('height', '')
                if (width == '1' or height == '1') or ('track' in src.lower()):
                    self.result.has_tracking_pixels = True
                    break

# =============================================================================
# PHISHING ANALYZER (MAIN)
# =============================================================================

class PhishingAnalyzer:
    """Hauptklasse f√ºr Phishing-Analyse"""

    def __init__(self, cfg: dict):
        self.cfg = cfg
        phishing_cfg = cfg.get('phishing', {})

        # Ollama
        ollama_cfg = cfg.get('ollama', {})
        self.ollama_host = ollama_cfg.get('host', 'http://10.10.0.113:11434')
        self.ollama_model = ollama_cfg.get('model', 'qwen2.5:14b-instruct')
        self.ollama_timeout = ollama_cfg.get('timeout', 120)

        # Prompt laden
        prompt_file = phishing_cfg.get('prompt_file', os.path.join(CONFIG_DIR, 'phishing_prompt.txt'))
        self.prompt_template = self._load_prompt(prompt_file)

    def _load_prompt(self, filepath: str) -> str:
        """Lade externen Prompt"""
        try:
            if os.path.exists(filepath):
                with open(filepath, 'r') as f:
                    logger.info(f"Externer Prompt geladen: {filepath}")
                    return f.read()
        except Exception as e:
            logger.warning(f"Prompt-Datei nicht ladbar: {e}")

        # Fallback
        return """Du bist ein Senior IT-Sicherheitsanalyst einer deutschen Bank (SOC Level 3).
Analysiere die folgende E-Mail auf Phishing-Indikatoren.

Bewerte:
1. Header-Authentizit√§t (SPF/DKIM/DMARC)
2. Absender-Legitimit√§t
3. URL-Verd√§chtigkeit
4. Social Engineering Taktiken
5. Banking-spezifische Risiken

Gib eine Risikobewertung: LOW / MEDIUM / HIGH / CRITICAL
Begr√ºnde deine Einsch√§tzung kurz."""

    def analyze_eml(self, eml_path: str) -> PhishingAnalysisResult:
        """Analysiert eine EML/MSG-Datei"""
        logger.info(f"Starte Phishing-Analyse: {eml_path}")

        result = PhishingAnalysisResult(
            analysis_id=hashlib.md5(f"{eml_path}{datetime.now()}".encode()).hexdigest()[:12],
            timestamp=datetime.now().isoformat(),
            source_file=eml_path
        )

        # Dateityp erkennen
        file_type = detect_file_type_by_magic(eml_path)

        if file_type == 'ole':
            # MSG-Datei
            msg = self._parse_msg_file(eml_path)
        else:
            # EML-Datei
            msg = self._parse_eml_file(eml_path)

        if not msg:
            logger.error(f"Konnte Mail nicht parsen: {eml_path}")
            return result

        # Pr√ºfe auf eingebettete message/rfc822
        embedded_msg = self._extract_embedded_message(msg)
        if embedded_msg:
            logger.info("üìß Eingebettete message/rfc822 gefunden - analysiere innere Mail")
            msg = embedded_msg

        # Header-Analyse (mit verbessertem Multi-Source Parsing)
        logger.info("Analysiere Header...")
        header_analyzer = ImprovedHeaderAnalyzer(msg)
        result.header_analysis = header_analyzer.analyze()

        # Content-Analyse
        text_content, html_content = self._extract_body(msg)
        content_analyzer = ContentAnalyzer(text_content, html_content)
        result.content_analysis = content_analyzer.analyze()

        # URL-Analyse (max 20 URLs via Tor)
        max_urls = self.cfg.get('phishing', {}).get('max_urls_to_check', 20)
        urls_to_check = result.content_analysis.extracted_urls[:max_urls]

        if urls_to_check:
            logger.info(f"Analysiere {len(urls_to_check)} URLs via Tor...")
            with ThreadPoolExecutor(max_workers=5) as executor:
                futures = {executor.submit(self._analyze_url, url): url for url in urls_to_check}
                for future in as_completed(futures):
                    try:
                        url_result = future.result()
                        result.url_analyses.append(url_result)
                    except Exception as e:
                        logger.debug(f"URL-Analyse fehlgeschlagen: {e}")


        # OSINT-Analyse (v2.3.0)
        if self.cfg.get('osint', {}).get('otx', {}).get('enabled') or \
           self.cfg.get('osint', {}).get('abuseipdb', {}).get('enabled') or \
           self.cfg.get('osint', {}).get('virustotal', {}).get('enabled') or \
           self.cfg.get('osint', {}).get('spamhaus', {}).get('enabled', True):
            logger.info("F√ºhre OSINT-Analyse durch...")
            osint_analyzer = OSINTAnalyzer(self.cfg)
            
            # Sammle IOCs
            osint_ips = [result.header_analysis.originating_ip] if result.header_analysis.originating_ip else []
            osint_ips.extend([ip for hop in result.header_analysis.received_chain for ip in hop.get('ips', [])])
            
            osint_domains = list(set([u.domain for u in result.url_analyses if u.domain]))
            osint_urls = [u.url for u in result.url_analyses]
            
            result.osint_analysis = osint_analyzer.analyze_all(osint_ips, osint_domains, osint_urls)
        
        # KI-Analyse
        if self.cfg.get('ollama', {}).get('enabled', True):
            result.ai_analysis = self._get_ai_analysis(result)

        # Gesamtbewertung
        self._calculate_overall_score(result)

        # IOCs extrahieren
        result.iocs = self._extract_iocs(result)

        return result

    def _extract_embedded_message(self, msg) -> Optional[email.message.EmailMessage]:
        """Extrahiere eingebettete message/rfc822 aus Wrapper-Mail"""
        try:
            if msg.is_multipart():
                for part in msg.walk():
                    content_type = part.get_content_type()
                    
                    if content_type == 'message/rfc822':
                        # Eingebettete Mail gefunden
                        payload = part.get_payload(0)
                        if payload and isinstance(payload, email.message.EmailMessage):
                            logger.debug(f"Embedded Subject: {payload.get('Subject', 'N/A')}")
                            logger.debug(f"Embedded From: {payload.get('From', 'N/A')}")
                            return payload
        except Exception as e:
            logger.debug(f"Fehler beim Extrahieren von embedded message: {e}")
        
        return None

    def _parse_eml_file(self, filepath: str) -> Optional[email.message.EmailMessage]:
        """Parse EML-Datei"""
        try:
            with open(filepath, 'rb') as f:
                return BytesParser(policy=policy.default).parse(f)
        except Exception as e:
            logger.error(f"EML Parse-Fehler: {e}")
            return None

    def _parse_msg_file(self, filepath: str):
        """Parse MSG-Datei"""
        if not EXTRACT_MSG_AVAILABLE:
            logger.warning("extract_msg nicht installiert, verwende Fallback")
            return self._parse_eml_file(filepath)

        try:
            msg = extract_msg.Message(filepath)

            # Konvertiere zu email.message-√§hnlichem Objekt
            class MSGWrapper:
                def __init__(self, msg_obj):
                    self._msg = msg_obj
                    self._headers = {}
                    self._build_headers()

                def _build_headers(self):
                    # Extrahiere Header aus MSG
                    if hasattr(self._msg, 'header'):
                        header_text = self._msg.header.as_string() if self._msg.header else ""
                        for line in header_text.split('\n'):
                            if ':' in line:
                                key, val = line.split(':', 1)
                                self._headers[key.strip()] = val.strip()

                    # Fallback auf MSG-Properties
                    self._headers['From'] = getattr(self._msg, 'sender', '') or ''
                    self._headers['To'] = getattr(self._msg, 'to', '') or ''
                    self._headers['Subject'] = getattr(self._msg, 'subject', '') or ''
                    self._headers['Date'] = getattr(self._msg, 'date', '') or ''

                def get(self, key, default=''):
                    return self._headers.get(key, default)

                def get_all(self, key, default=None):
                    val = self._headers.get(key)
                    return [val] if val else (default or [])

                def is_multipart(self):
                    return False

                def keys(self):
                    return self._headers.keys()

                def __str__(self):
                    return str(self._headers)

                @property
                def body(self):
                    return getattr(self._msg, 'body', '') or ''

                @property
                def html_body(self):
                    return getattr(self._msg, 'htmlBody', '') or ''

            return MSGWrapper(msg)

        except Exception as e:
            logger.error(f"MSG Parse-Fehler: {e}")
            return self._parse_eml_file(filepath)

    def _extract_body(self, msg) -> Tuple[str, str]:
        """Extrahiere Text und HTML Body"""
        text_content = ""
        html_content = ""

        # F√ºr MSGWrapper
        if hasattr(msg, 'body'):
            text_content = msg.body or ""
            html_content = getattr(msg, 'html_body', '') or ""
            return text_content, html_content

        # F√ºr email.message
        if msg.is_multipart():
            for part in msg.walk():
                content_type = part.get_content_type()
                
                # √úberspringe message/rfc822 Parts (bereits extrahiert)
                if content_type == 'message/rfc822':
                    continue
                    
                try:
                    payload = part.get_payload(decode=True)
                    if payload:
                        charset = part.get_content_charset() or 'utf-8'
                        decoded = payload.decode(charset, errors='replace')

                        if content_type == 'text/plain':
                            text_content += decoded
                        elif content_type == 'text/html':
                            html_content += decoded
                except:
                    pass
        else:
            try:
                payload = msg.get_payload(decode=True)
                if payload:
                    text_content = payload.decode('utf-8', errors='replace')
            except:
                pass

        return text_content, html_content

    def _analyze_url(self, url: str) -> URLAnalysis:
        """Analysiere einzelne URL"""
        analyzer = URLAnalyzer(url)
        return analyzer.analyze()

    def _get_ai_analysis(self, result: PhishingAnalysisResult) -> str:
        """Hole KI-Bewertung von Ollama"""
        try:
            # Daten f√ºr Prompt aufbereiten
            data = {
                'from': result.header_analysis.from_address,
                'subject': result.header_analysis.subject,
                'spf': f"{result.header_analysis.spf_result} ({result.header_analysis.spf_source})",
                'dkim': f"{result.header_analysis.dkim_result} ({result.header_analysis.dkim_source})",
                'dmarc': f"{result.header_analysis.dmarc_result} ({result.header_analysis.dmarc_source})",
                'anomalies': result.header_analysis.anomalies,
                'routing_issues': result.header_analysis.routing_analysis.security_issues,
                'urls_count': len(result.url_analyses),
                'suspicious_urls': [u.url for u in result.url_analyses if u.url_risk_score > 20],
                'ceo_fraud': result.content_analysis.ceo_fraud_indicators,
                'bank_mentions': result.content_analysis.bank_mentions,
            }
            # OSINT-Daten (v2.3.0)
            osint_summary = {
                'threat_level': result.osint_analysis.overall_threat_level,
                'total_threats': result.osint_analysis.total_threat_indicators,
                'high_confidence_threats': result.osint_analysis.high_confidence_threats[:5],
                'ip_threats': [{'ip': ip.ip, 'score': ip.overall_threat_score, 'tags': ip.threat_tags} 
                              for ip in result.osint_analysis.ip_reputations if ip.overall_threat_score > 30],
                'domain_threats': [{'domain': d.domain, 'score': d.overall_threat_score, 'tags': d.threat_tags}
                                  for d in result.osint_analysis.domain_reputations if d.overall_threat_score > 30],
                'url_threats': [{'url': u.url[:50], 'score': u.overall_threat_score, 'tags': u.threat_tags}
                               for u in result.osint_analysis.url_reputations if u.overall_threat_score > 30]
            }
            data['osint'] = osint_summary


            prompt = f"{self.prompt_template}\n\nMail-Daten:\n{json.dumps(data, ensure_ascii=False, indent=2)}"

            logger.debug(f"Sende Anfrage an Ollama: {self.ollama_host}")
            
            r = requests.post(
                f"{self.ollama_host}/api/generate",
                json={"model": self.ollama_model, "prompt": prompt, "stream": False},
                timeout=self.ollama_timeout
            )
            r.raise_for_status()
            
            response = r.json().get("response", "").strip()
            logger.info(f"‚úÖ Ollama-Analyse erfolgreich ({len(response)} Zeichen)")
            return response

        except requests.exceptions.ConnectionError as e:
            logger.error(f"‚ùå Ollama nicht erreichbar ({self.ollama_host}): {e}")
            return f"Ollama Connection Error: {e}"
        except requests.exceptions.Timeout as e:
            logger.error(f"‚ùå Ollama Timeout (>{self.ollama_timeout}s): {e}")
            return f"Ollama Timeout: {e}"
        except Exception as e:
            logger.error(f"‚ùå Ollama-Analyse fehlgeschlagen: {e}")
            return f"KI-Analyse fehlgeschlagen: {e}"

    def _calculate_overall_score(self, result: PhishingAnalysisResult):
        """Berechne Gesamtscore und Verdict"""
        score = 0

        # Header-Score
        score += result.header_analysis.risk_score

        # Content-Score
        score += result.content_analysis.content_risk_score
        score += result.content_analysis.urgency_score // 2
        score += len(result.content_analysis.ceo_fraud_indicators) * 5

        # URL-Score
        for url in result.url_analyses:
            score += url.url_risk_score // 2

        result.overall_risk_score = min(score, 100)

        # Verdict
        if result.overall_risk_score >= 70:
            result.verdict = "malicious"
        elif result.overall_risk_score >= 40:
            result.verdict = "suspicious"
        elif result.overall_risk_score >= 20:
            result.verdict = "likely_clean"
        else:
            result.verdict = "clean"

    def _extract_iocs(self, result: PhishingAnalysisResult) -> Dict:
        """Extrahiere IOCs f√ºr MISP"""
        return {
            'email-src': [result.header_analysis.from_address] if result.header_analysis.from_address else [],
            'ip-src': [result.header_analysis.originating_ip] if result.header_analysis.originating_ip else [],
            'url': [u.url for u in result.url_analyses if u.url_risk_score > 30],
            'domain': list(set([u.domain for u in result.url_analyses if u.is_typosquatting])),
        }

# =============================================================================
# CAPE INTEGRATION (unver√§ndert)
# =============================================================================

def submit_to_cape(cfg: dict, sample_path: str) -> Optional[int]:
    """Submitte Sample an CAPE Sandbox"""
    try:
        submit_cfg = cfg.get("capesubmit", {})
        timeout = submit_cfg.get("timeout", 300)
        route = submit_cfg.get("route", "none")
        machine = submit_cfg.get("machine", "")
        
        cmd_args = [
            "/opt/CAPEv2/utils/submit.py",
            "--timeout", str(timeout),
        ]
        
        if route and route != "none":
            cmd_args.extend(["--route", route])
            logger.debug(f"üîí Routing via: {route}")
            
        if machine:
            cmd_args.extend(["--machine", machine])
            
        if submit_cfg.get("options"):
            cmd_args.extend(["--options", submit_cfg["options"]])
            
        cmd_args.append(sample_path)

        logger.info(f"üì§ CAPE Submit: {os.path.basename(sample_path)} (route={route}, timeout={timeout})")
        logger.debug(f"Command: {' '.join(cmd_args)}")
        
        result = subprocess.run(
            cmd_args,
            capture_output=True,
            text=True,
            timeout=60,
            check=False
        )
        
        if result.returncode == 0:
            match = re.search(r'added as task with ID (\d+)', result.stdout)
            if match:
                task_id = int(match.group(1))
                logger.info(f"‚úÖ Task erstellt: #{task_id}")
                return task_id
            
            match = re.search(r'Success: File.*ID (\d+)', result.stdout)
            if match:
                task_id = int(match.group(1))
                logger.info(f"‚úÖ Task erstellt: #{task_id}")
                return task_id
                
        logger.error(f"‚ùå CAPE Submit fehlgeschlagen (rc={result.returncode})")
        logger.error(f"STDOUT: {result.stdout}")
        logger.error(f"STDERR: {result.stderr}")
        return None

    except subprocess.TimeoutExpired:
        logger.error("‚ùå CAPE Submit Timeout (>60s)")
        return None
    except FileNotFoundError:
        logger.error("‚ùå /opt/CAPEv2/utils/submit.py nicht gefunden!")
        return None
    except Exception as e:
        logger.error(f"‚ùå CAPE Submit Exception: {e}")
        return None

def wait_for_cape_report(cfg: dict, task_id: int) -> Optional[Dict]:
    """Warte auf CAPE Report"""
    results_cfg = cfg.get("caperesults", {})
    analyses_dir = results_cfg.get("analyses_dir", "/opt/CAPEv2/storage/analyses")
    max_wait = results_cfg.get("max_wait", 1800)
    poll_interval = results_cfg.get("poll_interval", 30)

    report_path = os.path.join(analyses_dir, str(task_id), "reports", "report.json")

    start_time = time.time()
    while time.time() - start_time < max_wait:
        if os.path.exists(report_path):
            try:
                with open(report_path, 'r') as f:
                    return json.load(f)
            except:
                pass

        logger.info(f"‚è≥ Warte auf Report f√ºr Task #{task_id}...")
        time.sleep(poll_interval)

    logger.warning(f"‚ö†Ô∏è Timeout beim Warten auf Report f√ºr Task #{task_id}")
    return None

def get_ollama_analysis(cfg: dict, report: Dict, sample_meta: Dict) -> str:
    """Hole KI-Bewertung von Ollama"""
    ollama_cfg = cfg.get("ollama", {})
    if not ollama_cfg.get("enabled", True):
        return "Ollama deaktiviert"

    host = ollama_cfg.get("host", "http://10.10.0.113:11434")
    model = ollama_cfg.get("model", "qwen2.5:14b-instruct")
    timeout = ollama_cfg.get("timeout", 180)

    prompt_file = "/opt/cape-mailer/config/cape_analysis_prompt.txt"
    try:
        with open(prompt_file, 'r') as f:
            base_prompt = f.read()
    except:
        base_prompt = """Du bist ein ITSO Security Analyst Level 3 in einer deutschen Bank.
Analysiere den CAPE Sandbox-Report und gib eine Bewertung mit:
- Risiko-Level (CRITICAL/HIGH/MEDIUM/LOW)
- Banking-Relevanz
- Empfohlene Ma√ünahmen
- BAIT/DORA Compliance-Hinweise
- IOCs zum Blocken"""

    info = report.get('info', {})
    signatures = report.get('signatures', [])
    network = report.get('network', {})
    behavior = report.get('behavior', {})

    report_summary = {
        'score': info.get('score', 0),
        'duration': info.get('duration', 0),
        'signatures': [{'name': s.get('name'), 'severity': s.get('severity'), 'description': s.get('description', '')[:200]} for s in signatures[:20]],
        'network': {
            'hosts': network.get('hosts', [])[:10],
            'domains': network.get('domains', [])[:10],
            'dns': network.get('dns', [])[:10],
            'http': [{'uri': h.get('uri', ''), 'method': h.get('method', '')} for h in network.get('http', [])[:10]]
        },
        'processes': len(behavior.get('processes', [])),
        'files_written': len(behavior.get('summary', {}).get('write_files', [])),
        'registry_written': len(behavior.get('summary', {}).get('write_keys', []))
    }

    prompt = f"""{base_prompt}

---

**SAMPLE-INFORMATIONEN:**
{json.dumps(sample_meta, ensure_ascii=False, indent=2)}

**CAPE-REPORT:**
{json.dumps(report_summary, ensure_ascii=False, indent=2)}
""".strip()

    logger.info(f"ü§ñ Starte ITSO L3 Ollama-Analyse mit Modell {model}")

    try:
        r = requests.post(
            f"{host}/api/generate",
            json={"model": model, "prompt": prompt, "stream": False},
            timeout=timeout
        )
        r.raise_for_status()
        response = r.json().get("response", "").strip()
        if response:
            logger.info("‚úÖ Ollama ITSO L3 Analyse erfolgreich")
            return response
        return "Keine LLM-Antwort erhalten."
    except Exception as e:
        logger.error(f"‚ùå Ollama-Analyse fehlgeschlagen: {e}")
        return f"Ollama-Fehler: {e}"

# =============================================================================
# REPORT GENERATION (Enhanced)
# =============================================================================

def generate_html_report(result: PhishingAnalysisResult) -> str:
    """Generiere HTML-Report f√ºr Phishing-Analyse mit OSINT"""
    import json
    from datetime import datetime
    
    verdict_colors = {'malicious': '#dc3545', 'suspicious': '#ffc107', 'likely_clean': '#17a2b8', 'clean': '#28a745', 'unknown': '#6c757d'}
    verdict_icons = {'malicious': 'üî¥', 'suspicious': 'üü°', 'likely_clean': 'üü¢', 'clean': 'üü¢', 'unknown': '‚ö™'}
    color = verdict_colors.get(result.verdict, '#6c757d')
    icon = verdict_icons.get(result.verdict, '‚ö™')
    
    # Routing HTML
    routing = result.header_analysis.routing_analysis
    routing_hops_html = "".join([
        f"<tr><td>{h.index}</td><td>{h.from_server or 'N/A'}</td><td>{h.to_server or 'N/A'}</td>"
        f"<td>{', '.join(h.ips) if h.ips else 'N/A'}</td><td>{h.tls_version or 'N/A'}</td>"
        f"<td>{h.cipher[:30] if h.cipher else 'N/A'}</td></tr>"
        for h in routing.hops
    ]) or '<tr><td colspan="6"><em>Keine Routing-Info</em></td></tr>'
    
    # Recommendations HTML
    recommendations_html = ""
    for rec in routing.recommendations:
        sev_color = {'high': '#dc3545', 'medium': '#ffc107', 'low': '#28a745'}.get(rec.get('severity'), '#6c757d')
        config_items = "\n".join([f"{k}: {v}" for k, v in rec.items() if k.startswith('config_')])
        recommendations_html += f'<div class="recommendation" style="border-left:4px solid {sev_color};margin:10px 0;padding:10px;background:#f8f9fa;">'
        recommendations_html += f'<strong style="color:{sev_color};">{rec["system"]}</strong>'
        recommendations_html += f'<p><strong>Issue:</strong> {rec["issue"]}</p>'
        recommendations_html += f'<p><strong>Recommendation:</strong> {rec["recommendation"]}</p>'
        recommendations_html += f'<pre style="background:white;padding:8px;font-size:11px;overflow-x:auto;">{config_items}</pre></div>'
    
    if not recommendations_html:
        recommendations_html = '<p><em>Keine Empfehlungen - System optimal konfiguriert!</em></p>'
    
    # OSINT HTML (korrekt, ohne verschachtelte f-Strings)
    osint_color = '#dc3545' if result.osint_analysis.overall_threat_level in ['critical','high'] else '#ffc107' if result.osint_analysis.overall_threat_level == 'medium' else '#28a745'
    
    osint_threats_html = ""
    if result.osint_analysis.high_confidence_threats:
        osint_threats_html = '<div class="section"><strong>‚ö†Ô∏è High-Confidence Threats:</strong><br>'
        osint_threats_html += "".join([f'<span class="tag tag-danger">{t}</span>' for t in result.osint_analysis.high_confidence_threats])
        osint_threats_html += '</div>'
    
    # IP Table
    ip_rows = []
    for ip in result.osint_analysis.ip_reputations[:10]:
        risk = 'risk-high' if ip.overall_threat_score > 60 else 'risk-medium' if ip.overall_threat_score > 30 else ''
        tags = "".join([f'<span class="tag">{t}</span>' for t in ip.threat_tags]) if ip.threat_tags else '<em>Clean</em>'
        ip_rows.append(f'<tr><td>{ip.ip}</td><td class="{risk}">{ip.overall_threat_score}/100</td><td>{tags}</td></tr>')
    ip_table = "".join(ip_rows) if ip_rows else '<tr><td colspan="3"><em>Keine IPs analysiert</em></td></tr>'
    
    # Domain Table
    domain_rows = []
    for d in result.osint_analysis.domain_reputations[:10]:
        risk = 'risk-high' if d.overall_threat_score > 60 else 'risk-medium' if d.overall_threat_score > 30 else ''
        tags = "".join([f'<span class="tag">{t}</span>' for t in d.threat_tags]) if d.threat_tags else '<em>Clean</em>'
        domain_rows.append(f'<tr><td>{d.domain}</td><td class="{risk}">{d.overall_threat_score}/100</td><td>{tags}</td></tr>')
    domain_table = "".join(domain_rows) if domain_rows else '<tr><td colspan="3"><em>Keine Domains analysiert</em></td></tr>'
    
    # URL Table
    url_rows = []
    for u in result.osint_analysis.url_reputations[:20]:
        risk = 'risk-high' if u.overall_threat_score > 60 else 'risk-medium' if u.overall_threat_score > 30 else ''
        tags = "".join([f'<span class="tag">{t}</span>' for t in u.threat_tags]) if u.threat_tags else '<em>Clean</em>'
        url_short = u.url[:60] + '...' if len(u.url) > 60 else u.url
        url_rows.append(f'<tr><td style="word-break:break-all;">{url_short}</td><td class="{risk}">{u.overall_threat_score}/100</td><td>{tags}</td></tr>')
    url_table = "".join(url_rows) if url_rows else '<tr><td colspan="3"><em>Keine URLs analysiert</em></td></tr>'
    
    # URL Analyse Table
    url_analysis_rows = []
    for u in result.url_analyses[:20]:
        url_short = u.url[:80] + '...' if len(u.url) > 80 else u.url
        reachable = '‚úÖ' if u.is_reachable else '‚ùå'
        login = '‚ö†Ô∏è' if u.has_login_form else '-'
        typo = f'üö® {u.typosquatting_target}' if u.is_typosquatting else '-'
        url_analysis_rows.append(f'<tr><td style="word-break:break-all;">{url_short}</td><td>{reachable}</td><td>{login}</td><td>{typo}</td><td>{u.url_risk_score}</td></tr>')
    url_analysis_table = "".join(url_analysis_rows) if url_analysis_rows else '<tr><td colspan="5"><em>Keine URLs gefunden</em></td></tr>'
    
    # Anomalien
    anomalies_html = "".join([f'<span class="tag tag-warning">{a}</span>' for a in result.header_analysis.anomalies]) or '<em>Keine Anomalien erkannt</em>'
    
    # Security Systems
    security_systems_html = "".join([f'<span class="tag">{s}</span>' for s in result.header_analysis.security_systems]) or '<em>Keine erkannt</em>'
    
    # Security Issues
    security_issues_html = ""
    if routing.security_issues:
        security_issues_html = f'<p class="risk-high"><strong>‚ö†Ô∏è Security Issues:</strong> {", ".join(routing.security_issues)}</p>'
    
    html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Phishing-Analyse Report - {result.analysis_id}</title>
    <style>
        body {{ font-family: 'Segoe UI', Arial, sans-serif; margin: 20px; background: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
        h1 {{ color: #333; border-bottom: 3px solid {color}; padding-bottom: 10px; }}
        h2, h3 {{ color: #555; margin-top: 30px; }}
        .verdict {{ font-size: 24px; font-weight: bold; color: {color}; padding: 15px; background: #f8f9fa; border-radius: 5px; border-left: 5px solid {color}; }}
        .score {{ font-size: 48px; color: {color}; }}
        table {{ width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 13px; }}
        th, td {{ padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }}
        th {{ background: #f8f9fa; }}
        .risk-high {{ color: #dc3545; font-weight: bold; }}
        .risk-medium {{ color: #ffc107; }}
        .risk-low {{ color: #28a745; }}
        .tag {{ display: inline-block; padding: 3px 8px; margin: 2px; background: #e9ecef; border-radius: 3px; font-size: 12px; }}
        .tag-warning {{ background: #fff3cd; color: #856404; }}
        .tag-danger {{ background: #f8d7da; color: #721c24; }}
        pre {{ background: #f8f9fa; padding: 15px; border-radius: 5px; overflow-x: auto; white-space: pre-wrap; font-size: 12px; }}
        .section {{ margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 5px; }}
        .info-badge {{ display: inline-block; background: #17a2b8; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; margin-left: 5px; }}
    </style>
</head>
<body>
<div class="container">
    <h1>{icon} Phishing-Analyse Report</h1>
    <div class="verdict">Verdict: {result.verdict.upper()}<span class="score" style="float:right;">{result.overall_risk_score}/100</span></div>
    <p><strong>Analyse-ID:</strong> {result.analysis_id}<br><strong>Zeitstempel:</strong> {result.timestamp}<br><strong>Quelldatei:</strong> {os.path.basename(result.source_file)}</p>

    <h2>üìß Header-Analyse</h2>
    <table>
        <tr><th>Feld</th><th>Wert</th></tr>
        <tr><td>Von</td><td>{result.header_analysis.from_address}</td></tr>
        <tr><td>Display Name</td><td>{result.header_analysis.from_display}</td></tr>
        <tr><td>Betreff</td><td>{result.header_analysis.subject}</td></tr>
        <tr><td>Reply-To</td><td>{result.header_analysis.reply_to or '-'}</td></tr>
        <tr><td>Return-Path</td><td>{result.header_analysis.return_path or '-'}</td></tr>
        <tr><td>Originating IP</td><td>{result.header_analysis.originating_ip or 'Nicht ermittelt'}</td></tr>
    </table>

    <h3>üîê Authentifizierung <span class="info-badge">Multi-Source</span></h3>
    <table>
        <tr><th>Check</th><th>Ergebnis</th><th>Quelle</th></tr>
        <tr><td>SPF</td><td class="{'risk-high' if result.header_analysis.spf_result in ['fail','softfail','temperror','permerror'] else ''}">{result.header_analysis.spf_result}</td><td>{result.header_analysis.spf_source}</td></tr>
        <tr><td>DKIM</td><td class="{'risk-high' if result.header_analysis.dkim_result == 'fail' else ''}">{result.header_analysis.dkim_result}</td><td>{result.header_analysis.dkim_source}</td></tr>
        <tr><td>DMARC</td><td class="{'risk-high' if result.header_analysis.dmarc_result == 'fail' else ''}">{result.header_analysis.dmarc_result}</td><td>{result.header_analysis.dmarc_source}</td></tr>
    </table>

    <h3>üõ°Ô∏è Mail-Routing-Analyse <span class="info-badge">TLS/Cipher-Check</span></h3>
    <table>
        <tr><th>#</th><th>From Server</th><th>To Server</th><th>IPs</th><th>TLS</th><th>Cipher</th></tr>
        {routing_hops_html}
    </table>
    <p><strong>TLS Encryption:</strong> {'‚úÖ Ja' if routing.uses_tls else '‚ùå Nein'} | <strong>ARC Headers:</strong> {'‚úÖ Ja' if routing.has_arc else '‚ùå Nein'}</p>
    {security_issues_html}

    <h3>‚ö†Ô∏è Anomalien</h3>
    <div class="section">{anomalies_html}</div>

    <h3>üõ°Ô∏è Security-Systeme in der Kette</h3>
    <div class="section">{security_systems_html}</div>

    <h2>üîß Security-Recommendations f√ºr Mail-Gateway-Tuning</h2>
    {recommendations_html}

    <h2>üîó URL-Analyse ({len(result.url_analyses)} URLs)</h2>
    <table>
        <tr><th>URL</th><th>Erreichbar</th><th>Login-Form</th><th>Typosquatting</th><th>Score</th></tr>
        {url_analysis_table}
    </table>

    <h2>üìù Inhaltsanalyse</h2>
    <table>
        <tr><th>Indikator</th><th>Wert</th></tr>
        <tr><td>Extrahierte URLs</td><td>{len(result.content_analysis.extracted_urls)}</td></tr>
        <tr><td>IBANs (maskiert)</td><td>{', '.join(result.content_analysis.extracted_ibans) or '-'}</td></tr>
        <tr><td>CEO-Fraud Indikatoren</td><td class="{'risk-high' if result.content_analysis.ceo_fraud_indicators else ''}">{', '.join(result.content_analysis.ceo_fraud_indicators) or '-'}</td></tr>
        <tr><td>Bank-Erw√§hnungen</td><td>{', '.join(result.content_analysis.bank_mentions) or '-'}</td></tr>
        <tr><td>Urgency-Score</td><td>{result.content_analysis.urgency_score}/100</td></tr>
        <tr><td>Tracking-Pixel</td><td>{'‚ö†Ô∏è Ja' if result.content_analysis.has_tracking_pixels else 'Nein'}</td></tr>
    </table>

    <h2>üîç OSINT Threat Intelligence <span class="info-badge">v2.3.0</span></h2>
    <div class="verdict" style="border-color:{osint_color};">Threat Level: {result.osint_analysis.overall_threat_level.upper()}<span style="float:right;">{result.osint_analysis.total_threat_indicators} High-Confidence Threats</span></div>
    {osint_threats_html}
    
    <h3>üåê IP Reputation ({len(result.osint_analysis.ip_reputations)} IPs)</h3>
    <table><tr><th>IP</th><th>Threat Score</th><th>Threat Indicators</th></tr>{ip_table}</table>
    
    <h3>üè∑Ô∏è Domain Reputation ({len(result.osint_analysis.domain_reputations)} Domains)</h3>
    <table><tr><th>Domain</th><th>Threat Score</th><th>Threat Indicators</th></tr>{domain_table}</table>
    
    <h3>üîó URL Reputation ({len(result.osint_analysis.url_reputations)} URLs)</h3>
    <table><tr><th>URL</th><th>Threat Score</th><th>Threat Indicators</th></tr>{url_table}</table>

    <h2>ü§ñ KI-Bewertung</h2>
    <div class="section"><pre>{result.ai_analysis or 'Keine KI-Analyse verf√ºgbar'}</pre></div>

    <h2>üéØ IOCs (MISP-ready)</h2>
    <pre>{json.dumps(result.iocs, indent=2, ensure_ascii=False)}</pre>

    <hr>
    <p style="color:#666;font-size:12px;">Generiert von CAPE Phishing Analyzer v2.3.0 (OSINT Integration)<br>{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
</div>
</body>
</html>"""
    return html


def generate_splunk_log(result: PhishingAnalysisResult) -> Dict:
    """Generiere Splunk-kompatibles JSON-Log"""
    return {
        "version": "2.2.9",
        "event_type": "phishing_analysis",
        "analysis_id": result.analysis_id,
        "timestamp": result.timestamp,
        "source_file": result.source_file,

        # Header
        "from_address": result.header_analysis.from_address,
        "from_display": result.header_analysis.from_display,
        "from_domain": result.header_analysis.from_address.split('@')[-1] if '@' in result.header_analysis.from_address else "",
        "reply_to": result.header_analysis.reply_to,
        "subject": result.header_analysis.subject,
        "originating_ip": result.header_analysis.originating_ip,

        # Auth (mit Quellen)
        "spf_result": result.header_analysis.spf_result,
        "spf_source": result.header_analysis.spf_source,
        "dkim_result": result.header_analysis.dkim_result,
        "dkim_source": result.header_analysis.dkim_source,
        "dmarc_result": result.header_analysis.dmarc_result,
        "dmarc_source": result.header_analysis.dmarc_source,

        # Routing
        "routing_hops": result.header_analysis.routing_analysis.total_hops,
        "routing_uses_tls": result.header_analysis.routing_analysis.uses_tls,
        "routing_weak_tls": result.header_analysis.routing_analysis.weak_tls,
        "routing_weak_cipher": result.header_analysis.routing_analysis.weak_cipher,
        "routing_has_arc": result.header_analysis.routing_analysis.has_arc,
        "routing_issues": result.header_analysis.routing_analysis.security_issues,

        # Scores
        "header_risk_score": result.header_analysis.risk_score,
        "content_risk_score": result.content_analysis.content_risk_score,
        "overall_risk_score": result.overall_risk_score,
        "verdict": result.verdict,

        # Counts
        "anomalies_count": len(result.header_analysis.anomalies),
        "anomalies": result.header_analysis.anomalies,
        "security_systems_count": len(result.header_analysis.security_systems),
        "security_systems": result.header_analysis.security_systems,
        "urls_count": len(result.url_analyses),
        "urls_with_login": len([u for u in result.url_analyses if u.has_login_form]),
        "urls_typosquatting": len([u for u in result.url_analyses if u.is_typosquatting]),
        "ceo_fraud_indicators": result.content_analysis.ceo_fraud_indicators,
        "bank_mentions": result.content_analysis.bank_mentions,
        "ibans_found": len(result.content_analysis.extracted_ibans),
        "urgency_score": result.content_analysis.urgency_score,


        # OSINT (v2.3.0)
        "osint_threat_level": result.osint_analysis.overall_threat_level,
        "osint_total_threats": result.osint_analysis.total_threat_indicators,
        "osint_high_confidence_threats": result.osint_analysis.high_confidence_threats,
        "osint_ip_threats": len([ip for ip in result.osint_analysis.ip_reputations if ip.overall_threat_score > 30]),
        "osint_domain_threats": len([d for d in result.osint_analysis.domain_reputations if d.overall_threat_score > 30]),
        "osint_url_threats": len([u for u in result.osint_analysis.url_reputations if u.overall_threat_score > 30]),
        # IOCs
        "iocs": result.iocs,
    }

def generate_cape_html_report(sample_name: str, task_id: int, report: Dict,
                              ai_analysis: str, malscore: float) -> str:
    """Generiere HTML-Report f√ºr CAPE-Analyse"""

    if malscore >= 7:
        color = '#dc3545'
        verdict = 'MALICIOUS'
        icon = 'üî¥'
    elif malscore >= 4:
        color = '#ffc107'
        verdict = 'SUSPICIOUS'
        icon = 'üü°'
    else:
        color = '#28a745'
        verdict = 'CLEAN'
        icon = 'üü¢'

    signatures = report.get('signatures', [])
    sig_html = ""
    for sig in signatures[:20]:
        severity = sig.get('severity', 1)
        sev_class = 'risk-high' if severity >= 3 else 'risk-medium' if severity >= 2 else ''
        sig_html += f"<tr><td class='{sev_class}'>{sig.get('name', 'Unknown')}</td><td>{sig.get('description', '')[:100]}</td><td>{severity}</td></tr>"

    network = report.get('network', {})
    domains = network.get('domains', [])
    hosts = network.get('hosts', [])

    html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>CAPE Analyse - {sample_name}</title>
    <style>
        body {{ font-family: 'Segoe UI', Arial, sans-serif; margin: 20px; background: #f5f5f5; }}
        .container {{ max-width: 900px; margin: auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
        h1 {{ color: #333; border-bottom: 3px solid {color}; padding-bottom: 10px; }}
        .verdict {{ font-size: 24px; font-weight: bold; color: {color}; padding: 15px; background: #f8f9fa; border-radius: 5px; border-left: 5px solid {color}; }}
        .score {{ font-size: 48px; color: {color}; }}
        table {{ width: 100%; border-collapse: collapse; margin: 15px 0; }}
        th, td {{ padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }}
        th {{ background: #f8f9fa; }}
        .risk-high {{ color: #dc3545; font-weight: bold; }}
        .risk-medium {{ color: #ffc107; }}
        pre {{ background: #f8f9fa; padding: 15px; border-radius: 5px; overflow-x: auto; white-space: pre-wrap; }}
    </style>
</head>
<body>
<div class="container">
    <h1>{icon} CAPE Sandbox Analyse</h1>

    <div class="verdict">
        Verdict: {verdict}
        <span class="score" style="float:right;">{malscore:.1f}/10</span>
    </div>

    <p><strong>Sample:</strong> {sample_name}<br>
    <strong>Task-ID:</strong> #{task_id}<br>
    <strong>Zeitstempel:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>

    <h2>üîç Signaturen ({len(signatures)})</h2>
    <table>
        <tr><th>Name</th><th>Beschreibung</th><th>Severity</th></tr>
        {sig_html or '<tr><td colspan="3"><em>Keine Signaturen</em></td></tr>'}
    </table>

    <h2>üåê Netzwerk-IOCs</h2>
    <p><strong>Domains:</strong> {', '.join([d.get('domain','') for d in domains[:10]]) or 'Keine'}</p>
    <p><strong>IPs:</strong> {', '.join([h.get('ip','') for h in hosts[:10]]) or 'Keine'}</p>


    <h2>üîç OSINT Threat Intelligence <span class="info-badge">v2.3.0</span></h2>
    <div class="verdict" style="border-color: {'#dc3545' if result.osint_analysis.overall_threat_level in ['critical','high'] else '#ffc107' if result.osint_analysis.overall_threat_level == 'medium' else '#28a745'};">
        Threat Level: {result.osint_analysis.overall_threat_level.upper()}
        <span style="float:right;">{result.osint_analysis.total_threat_indicators} High-Confidence Threats</span>
    </div>
    
    {f'<div class="section"><strong>‚ö†Ô∏è High-Confidence Threats:</strong><br>' + '<br>'.join([f'<span class="tag tag-danger">{t}</span>' for t in result.osint_analysis.high_confidence_threats]) + '</div>' if result.osint_analysis.high_confidence_threats else ''}
    
    <h3>üåê IP Reputation ({len(result.osint_analysis.ip_reputations)} IPs)</h3>
    <table>
        <tr><th>IP</th><th>Threat Score</th><th>Threat Indicators</th></tr>
        {''.join([f"<tr><td>{ip.ip}</td><td class="{'risk-high' if ip.overall_threat_score > 60 else 'risk-medium' if ip.overall_threat_score > 30 else ''}">{ip.overall_threat_score}/100</td><td>{''.join([f'<span class="tag">{t}</span>' for t in ip.threat_tags]) or '<em>Clean</em>'}</td></tr>" for ip in result.osint_analysis.ip_reputations[:10]]) or '<tr><td colspan="3"><em>Keine IPs analysiert</em></td></tr>'}
    </table>
    
    <h3>üè∑Ô∏è Domain Reputation ({len(result.osint_analysis.domain_reputations)} Domains)</h3>
    <table>
        <tr><th>Domain</th><th>Threat Score</th><th>Threat Indicators</th></tr>
        {''.join([f"<tr><td>{d.domain}</td><td class="{'risk-high' if d.overall_threat_score > 60 else 'risk-medium' if d.overall_threat_score > 30 else ''}">{d.overall_threat_score}/100</td><td>{''.join([f'<span class="tag">{t}</span>' for t in d.threat_tags]) or '<em>Clean</em>'}</td></tr>" for d in result.osint_analysis.domain_reputations[:10]]) or '<tr><td colspan="3"><em>Keine Domains analysiert</em></td></tr>'}
    </table>
    
    <h3>üîó URL Reputation ({len(result.osint_analysis.url_reputations)} URLs)</h3>
    <table>
        <tr><th>URL</th><th>Threat Score</th><th>Threat Indicators</th></tr>
        {''.join([f"<tr><td style='word-break:break-all;'>{u.url[:60]}...</td><td class="{'risk-high' if u.overall_threat_score > 60 else 'risk-medium' if u.overall_threat_score > 30 else ''}">{u.overall_threat_score}/100</td><td>{''.join([f'<span class="tag">{t}</span>' for t in u.threat_tags]) or '<em>Clean</em>'}</td></tr>" for u in result.osint_analysis.url_reputations[:20]]) or '<tr><td colspan="3"><em>Keine URLs analysiert</em></td></tr>'}
    </table>

    <h2>ü§ñ KI-Bewertung</h2>
    <pre>{ai_analysis}</pre>

    <hr>
    <p style="color:#666; font-size:12px;">CAPE Mailer v2.2.9</p>
</div>
</body>
</html>"""

    return html

# =============================================================================
# EMAIL SENDING
# =============================================================================

def send_mail(cfg: dict, to_addr: str, subject: str, html_body: str,
              cc_addr: str = None, attachments: List[Tuple[str, bytes]] = None) -> bool:
    """Sende E-Mail mit verbessertem Error Handling"""
    smtp_cfg = cfg.get("smtp", {})
    
    if not smtp_cfg.get("host"):
        logger.error("‚ùå SMTP host nicht konfiguriert!")
        return False
        
    if not smtp_cfg.get("port"):
        logger.error("‚ùå SMTP port nicht konfiguriert!")
        return False

    msg = EmailMessage()
    msg['From'] = smtp_cfg.get("from", "cape@example.com")
    msg['To'] = to_addr
    msg['Subject'] = subject
    msg['Date'] = formatdate(localtime=True)

    if cc_addr:
        msg['Cc'] = cc_addr

    msg.set_content("Dieser Report erfordert einen HTML-f√§higen Mail-Client.")
    msg.add_alternative(html_body, subtype='html')

    if attachments:
        for filename, data in attachments:
            msg.add_attachment(data, maintype='application', subtype='octet-stream', filename=filename)

    try:
        logger.debug(f"üìß Verbinde mit SMTP {smtp_cfg.get('host')}:{smtp_cfg.get('port')}")
        
        ssl_context = ssl.create_default_context()
        ssl_context.check_hostname = False
        ssl_context.verify_mode = ssl.CERT_NONE

        with smtplib.SMTP(smtp_cfg.get("host"), int(smtp_cfg.get("port", 587)), timeout=30) as server:
            logger.debug("‚úÖ SMTP Verbindung hergestellt")
            
            if smtp_cfg.get("starttls", True):
                server.starttls(context=ssl_context)
                logger.debug("‚úÖ STARTTLS erfolgreich")

            if smtp_cfg.get("user") and smtp_cfg.get("pass"):
                server.login(smtp_cfg["user"], smtp_cfg["pass"])
                logger.debug("‚úÖ SMTP Login erfolgreich")

            recipients = [to_addr]
            if cc_addr:
                recipients.append(cc_addr)

            server.send_message(msg, to_addrs=recipients)
            logger.info(f"‚úÖ Mail erfolgreich gesendet an {to_addr}")
            return True

    except ConnectionRefusedError as e:
        logger.error(f"‚ùå SMTP Server nicht erreichbar ({smtp_cfg.get('host')}:{smtp_cfg.get('port')}): {e}")
        logger.error("üí° Pr√ºfe: sudo systemctl status postfix (oder exim4)")
        return False
    except smtplib.SMTPAuthenticationError as e:
        logger.error(f"‚ùå SMTP Authentifizierung fehlgeschlagen: {e}")
        logger.error(f"üí° User: {smtp_cfg.get('user')}")
        return False
    except socket.gaierror as e:
        logger.error(f"‚ùå SMTP Hostname nicht aufl√∂sbar ({smtp_cfg.get('host')}): {e}")
        return False
    except Exception as e:
        logger.error(f"‚ùå Mail-Versand fehlgeschlagen: {e}")
        logger.debug(f"SMTP Config: host={smtp_cfg.get('host')}, port={smtp_cfg.get('port')}, user={smtp_cfg.get('user')}")
        return False

# =============================================================================
# MAIN PROCESSING (unver√§ndert)
# =============================================================================

def fetch_mailbox(cfg: dict) -> List[Dict]:
    """Hole ungelesene Mails aus IMAP"""
    imap_cfg = cfg.get("imap", {})

    ssl_context = ssl.create_default_context()
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE

    mails = []

    try:
        use_ssl = imap_cfg.get("ssl", False)
        port = int(imap_cfg.get("port", 993 if use_ssl else 143))

        with IMAPClient(imap_cfg["host"], port=port, ssl=use_ssl, ssl_context=ssl_context) as client:
            if not use_ssl and imap_cfg.get("starttls", True):
                client.starttls(ssl_context=ssl_context)

            client.login(imap_cfg["user"], imap_cfg["pass"])
            client.select_folder(imap_cfg.get("folder", "INBOX"))

            uids = client.search(["UNSEEN"])
            logger.info(f"Gefunden: {len(uids)} ungelesene E-Mails")

            for uid in uids:
                try:
                    raw = client.fetch([uid], ["RFC822"])[uid][b"RFC822"]
                    msg = pyzmail.PyzMessage.factory(raw)

                    from_addr = msg.get_addresses("from")[0][1] if msg.get_addresses("from") else ""
                    subj = msg.get_subject() or "(kein Betreff)"

                    body_text = ""
                    if msg.text_part:
                        try:
                            body_text = msg.text_part.get_payload().decode(
                                msg.text_part.charset or 'utf-8', errors='replace')
                        except:
                            pass

                    password = extract_password_from_text(body_text)

                    work_dir = os.path.join(WORK, f"mail_{uid}_{int(time.time())}")
                    os.makedirs(work_dir, exist_ok=True)

                    attachments = []

                    for part in msg.mailparts:
                        if part.is_body:
                            continue

                        payload = part.get_payload()
                        if not payload:
                            continue

                        if isinstance(payload, str):
                            payload = payload.encode('utf-8', errors='replace')

                        filename = part.filename or f"attachment_{len(attachments)}"

                        if len(payload) > 8:
                            magic = payload[:8]
                            logger.debug(f"Part: filename={filename}, type={part.type}, payload_len={len(payload)}")
                            logger.debug(f"Attachment Magic Bytes: {magic.hex()}")

                            if magic.startswith(b'\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1'):
                                if not filename.lower().endswith('.msg'):
                                    filename = os.path.splitext(filename)[0] + '.msg'
                                    logger.info(f"MSG-Format erkannt via Magic Bytes")
                            elif magic.startswith(b'MZ'):
                                if not os.path.splitext(filename)[1]:
                                    filename = filename + '.exe'
                                    logger.debug(f"EXE-Format erkannt via Magic Bytes")

                        filepath = os.path.join(work_dir, filename)
                        with open(filepath, 'wb') as f:
                            f.write(payload)

                        attachments.append(filepath)
                        logger.info(f"Attachment: {filename} ({part.type}) -> {filepath}")

                    mails.append({
                        'uid': uid,
                        'from': from_addr,
                        'subject': subj,
                        'body': body_text,
                        'password': password,
                        'work_dir': work_dir,
                        'attachments': attachments,
                        'client': client,
                    })

                    logger.info(f"Mail #{uid}: {subj} von {from_addr} - {len(attachments)} Anh√§nge")

                except Exception as e:
                    logger.error(f"Fehler bei Mail #{uid}: {e}")
                    continue

            return mails

    except Exception as e:
        logger.error(f"IMAP-Fehler: {e}")
        return []

def process_mail(cfg: dict, mail_data: Dict) -> bool:
    """Verarbeite eine einzelne Mail"""
    uid = mail_data['uid']
    from_addr = mail_data['from']
    subj = mail_data['subject']
    password = mail_data.get('password')
    work_dir = mail_data['work_dir']
    attachments = mail_data['attachments']
    client = mail_data.get('client')

    logger.info(f"Verarbeite Mail #{uid}: {subj}")

    samples = []
    eml_files = []

    for attachment in attachments:
        ext = os.path.splitext(attachment)[1].lower()

        if ext in ['.zip', '.7z', '.rar']:
            extracted = try_extract_archive(attachment, work_dir, password)
            for f in extracted:
                if is_allowed(f, cfg):
                    samples.append(f)
                elif os.path.splitext(f)[1].lower() in EML_EXTENSIONS:
                    eml_files.append(f)

        elif ext in EML_EXTENSIONS or detect_file_type_by_magic(attachment) == 'ole':
            eml_files.append(attachment)

        elif is_allowed(attachment, cfg):
            samples.append(attachment)

    logger.info(f"Gefunden: {len(samples)} Sample(s), {len(eml_files)} E-Mail-Datei(en)")

    results_sent = False

    if eml_files and PHISHING_DEPS_AVAILABLE:
        analyzer = PhishingAnalyzer(cfg)

        for eml_file in eml_files:
            try:
                result = analyzer.analyze_eml(eml_file)

                html_report = generate_html_report(result)
                report_filename = f"phishing_{result.analysis_id}.html"
                report_path = os.path.join(REPORTS_DIR, report_filename)
                with open(report_path, 'w') as f:
                    f.write(html_report)
                logger.info(f"üíæ HTML-Report gespeichert: {report_path}")

                splunk_log = generate_splunk_log(result)
                splunk_path = os.path.join(SPLUNK_LOG_DIR, f"phishing_{datetime.now().strftime('%Y-%m-%d')}.json")
                with open(splunk_path, 'a') as f:
                    f.write(json.dumps(splunk_log) + "\n")

                verdict_icon = {'malicious': 'üî¥', 'suspicious': 'üü°', 'clean': 'üü¢'}.get(result.verdict, '‚ö™')
                mail_subject = f"[PHISHING ANALYSE] {verdict_icon} {result.verdict.upper()} - {subj}"

                if send_mail(cfg, from_addr, mail_subject, html_report, cc_addr=ALWAYS_CC):
                    results_sent = True
                else:
                    logger.warning("‚ö†Ô∏è Mail-Versand fehlgeschlagen, aber Report wurde gespeichert")
                    results_sent = True

            except Exception as e:
                logger.error(f"Phishing-Analyse fehlgeschlagen: {e}")

    if samples:
        for sample in samples:
            sample_name = os.path.basename(sample)
            sample_hash = get_file_hash(sample)

            logger.info(f"üî¨ Sample: {sample_name} (SHA256: {sample_hash[:16]}...)")

            task_id = submit_to_cape(cfg, sample)
            if not task_id:
                continue

            report = wait_for_cape_report(cfg, task_id)
            if not report:
                logger.warning(f"Kein Report f√ºr Task #{task_id}")
                continue

            malscore = report.get('info', {}).get('score', 0)
            sample_meta = {'name': sample_name, 'sha256': sample_hash, 'task_id': task_id}
            ai_analysis = get_ollama_analysis(cfg, report, sample_meta)

            html_report = generate_cape_html_report(sample_name, task_id, report, ai_analysis, malscore)
            report_path = os.path.join(REPORTS_DIR, f"cape_{task_id}_{sample_hash[:8]}.html")
            with open(report_path, 'w') as f:
                f.write(html_report)
            logger.info(f"üíæ CAPE-Report gespeichert: {report_path}")

            ampel_cfg = cfg.get("ampel", {})
            if malscore >= ampel_cfg.get("yellow_max_malscore", 4.9):
                verdict = "MALICIOUS"
                icon = "üî¥"
            elif malscore >= ampel_cfg.get("green_max_malscore", 1.9):
                verdict = "SUSPICIOUS"
                icon = "üü°"
            else:
                verdict = "CLEAN"
                icon = "üü¢"

            mail_subject = f"[CAPE ANALYSE] {icon} {verdict} (Score: {malscore:.1f}) - {sample_name}"
            if send_mail(cfg, from_addr, mail_subject, html_report, cc_addr=ALWAYS_CC):
                results_sent = True
            else:
                logger.warning("‚ö†Ô∏è Mail-Versand fehlgeschlagen, aber Report wurde gespeichert")
                results_sent = True

    return results_sent

def main():
    """Hauptfunktion"""
    logger.info("=" * 60)
    logger.info("CAPE Mailer v2.2.9 - Multi-Source Auth + Routing-Analyse gestartet")

    if '--debug' in sys.argv:
        logging.getLogger().setLevel(logging.DEBUG)
        logger.debug("üêõ Debug-Modus aktiviert")

    cfg = load_cfg()

    for d in [WORK, PROCESSED, QUAR, LOGDIR, REPORTS_DIR, SPLUNK_LOG_DIR]:
        os.makedirs(d, exist_ok=True)

    ollama_ok = check_ollama_available(cfg)
    cape_ok = check_cape_available()

    if ollama_ok:
        logger.info(f"‚úÖ Ollama erreichbar: {cfg.get('ollama', {}).get('host')}")
    else:
        logger.warning("‚ö†Ô∏è Ollama nicht erreichbar")

    if cape_ok:
        logger.info("‚úÖ CAPE API erreichbar")
    else:
        logger.warning("‚ö†Ô∏è CAPE API nicht erreichbar")

    mails = fetch_mailbox(cfg)

    if not mails:
        logger.info("üì≠ Keine neuen Mails")
        return

    logger.info(f"üì¨ {len(mails)} E-Mails zur Verarbeitung")

    ssl_context = ssl.create_default_context()
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE

    imap_cfg = cfg.get("imap", {})
    use_ssl = imap_cfg.get("ssl", False)
    port = int(imap_cfg.get("port", 993 if use_ssl else 143))

    with IMAPClient(imap_cfg["host"], port=port, ssl=use_ssl, ssl_context=ssl_context) as client:
        if not use_ssl and imap_cfg.get("starttls", True):
            client.starttls(ssl_context=ssl_context)

        client.login(imap_cfg["user"], imap_cfg["pass"])
        client.select_folder(imap_cfg.get("folder", "INBOX"))

        for mail_data in mails:
            uid = mail_data['uid']

            has_samples = any(is_allowed(a, cfg) for a in mail_data['attachments']
                            if os.path.splitext(a)[1].lower() not in EML_EXTENSIONS)

            if has_samples and not cape_ok:
                logger.warning(f"‚ö†Ô∏è Mail #{uid} √ºbersprungen - CAPE nicht verf√ºgbar")
                continue

            try:
                success = process_mail(cfg, mail_data)

                if success:
                    client.add_flags([uid], ['\\Seen'])
                    logger.info(f"‚úÖ Mail #{uid} als gelesen markiert")
                else:
                    logger.warning(f"‚ö†Ô∏è Mail #{uid} - keine Ergebnisse generiert")

            except Exception as e:
                logger.error(f"‚ùå Fehler bei Mail #{uid}: {e}")
                import traceback
                logger.debug(traceback.format_exc())

    logger.info("üèÅ Verarbeitung abgeschlossen")
    logger.info("=" * 60)

if __name__ == "__main__":
    main()

